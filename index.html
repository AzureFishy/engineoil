<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>V6 Engine Lubrication Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            color: #000;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Row 1: Header */
        header {
            text-align: center;
            padding: 8px 0;
            border-bottom: 2px solid #000;
        }

        h1 {
            font-size: clamp(16px, 4vw, 24px);
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .subtitle {
            color: #666;
            font-size: clamp(10px, 2.5vw, 13px);
            margin-top: 3px;
        }

        /* Row 2: Engine Visualization */
        .engine-canvas-wrapper {
            position: relative;
            background: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            overflow: hidden;
            flex-grow: 1;
            touch-action: none;
            min-height: 340px;
        }

        .engine-canvas-wrapper.warning {
            border-color: #cc0000;
            box-shadow: 0 0 20px rgba(204, 0, 0, 0.3);
        }

        #engineCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background: #fff;
            cursor: zoom-in;
        }

        #engineCanvas.zoomed {
            cursor: zoom-out;
        }

        /* ==================== CENTERED WARNING LIGHTS ==================== */
        
        .warning-lights-top {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }

        .warning-light {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #999;
            opacity: 0.05;
            transition: all 0.3s ease;
        }

        .warning-light .indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ddd;
            border: 1px solid #bbb;
            transition: all 0.3s ease;
        }

        .warning-light.active {
            color: #cc0000;
            opacity: 1;
        }

        .warning-light.active .indicator {
            background: #cc0000;
            border-color: #aa0000;
            box-shadow: 0 0 10px rgba(204, 0, 0, 0.8);
            animation: lightPulse 0.8s infinite;
        }

        @keyframes lightPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* ==================== LEFT SIDE HUD ==================== */
        
        .hud-left-panel {
            position: absolute;
            top: 8px;
            left: 8px;
            width: clamp(100px, 18vw, 160px);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .hud-status {
            background: #fff;
            border: 1px solid #000;
            border-radius: 4px;
            padding: 6px 8px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .hud-status:hover {
            background: #f8f8f8;
        }

        .hud-status.critical {
            border-color: #cc0000;
            background: #fff5f5;
        }

        .hud-status-label {
            font-size: 7px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666;
            margin-bottom: 2px;
        }

        .hud-status-stage {
            font-size: 11px;
            font-weight: 700;
            color: #000;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            transition: color 0.3s ease;
        }

        .hud-status-stage.stage-1 { color: #996600; }
        .hud-status-stage.stage-2 { color: #cc4400; }
        .hud-status-stage.stage-3 { color: #cc0000; }
        .hud-status-stage.stage-4 { color: #aa0000; font-weight: 800; }
        .hud-status-stage.stage-5 { color: #880000; animation: criticalPulse 0.5s infinite; }

        @keyframes criticalPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .hud-status-text {
            font-size: 8px;
            color: #666;
            margin-top: 2px;
        }

        .hud-problems {
            background: #fff;
            border: 1px solid #cc0000;
            border-radius: 4px;
            padding: 6px 8px;
            display: none;
            cursor: pointer;
        }

        .hud-problems:hover {
            background: #fff8f8;
        }

        .hud-problems.visible {
            display: block;
        }

        .hud-problems-list {
            list-style: none;
        }

        .hud-problems-list li {
            font-size: 8px;
            color: #cc0000;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .hud-problems-list li:last-child {
            margin-bottom: 0;
        }

        .problem-x {
            font-weight: 700;
            font-size: 9px;
        }

        .hud-condition {
            background: #fff;
            border: 1px solid #000;
            border-radius: 4px;
            padding: 6px 8px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .hud-condition:hover {
            background: #f8f8f8;
        }

        .hud-condition.critical {
            border-color: #cc0000;
            background: #fff5f5;
        }

        .hud-condition-text {
            font-size: 8px;
            color: #333;
            line-height: 1.3;
            text-align: left;
        }

        .hud-condition.critical .hud-condition-text {
            color: #cc0000;
        }

        /* ==================== RIGHT SIDE HUD ==================== */
        
        .hud-right-panel {
            position: absolute;
            top: 8px;
            right: 8px;
            bottom: 8px;
            width: clamp(90px, 16vw, 140px);
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 10;
        }

        .hud-rpm {
            background: #fff;
            border: 1px solid #000;
            border-radius: 4px;
            padding: 5px 8px;
            text-align: center;
            cursor: pointer;
        }

        .hud-rpm:hover {
            background: #f8f8f8;
        }

        .hud-rpm-label {
            font-size: 7px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
        }

        .hud-rpm-value-container {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 6px;
        }

        .hud-rpm-value {
            font-size: clamp(14px, 3vw, 20px);
            font-weight: 700;
            color: #000;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            line-height: 1.2;
            transition: color 0.3s ease;
        }

        .hud-rpm-value.critical {
            color: #cc0000;
        }

        .hud-rpm-reduction {
            font-size: clamp(8px, 1.5vw, 10px);
            font-weight: 600;
            color: #cc0000;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            line-height: 1;
            margin-top: 3px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .hud-rpm-reduction.visible {
            opacity: 1;
        }

        .hud-meters {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex-grow: 1;
        }

        .hud-meter {
            display: flex;
            align-items: stretch;
            gap: 0;
            cursor: pointer;
        }

        .hud-meter:hover .hud-meter-content {
            background: #f8f8f8;
        }

        .hud-meter.critical:hover .hud-meter-content {
            background: #fff0f0;
        }

        .hud-meter-warning {
            width: 16px;
            background: #cc0000;
            border-radius: 4px 0 0 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .hud-meter.critical .hud-meter-warning {
            opacity: 1;
            animation: warningFlash 1s infinite;
        }

        @keyframes warningFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .hud-meter-warning-icon {
            color: #fff;
            font-size: 10px;
            font-weight: bold;
        }

        .hud-meter-content {
            flex: 1;
            background: #fff;
            border: 1px solid #000;
            border-radius: 4px;
            padding: 5px 8px;
            transition: border-color 0.3s ease, background 0.3s ease;
        }

        .hud-meter.critical .hud-meter-content {
            border-color: #cc0000;
            border-left: none;
            border-radius: 0 4px 4px 0;
        }

        .hud-meter.critical .hud-meter-warning {
            border: 1px solid #cc0000;
            border-right: none;
        }

        .hud-meter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3px;
        }

        .hud-meter-label {
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666;
            font-weight: 600;
        }

        .hud-meter-value {
            font-size: 10px;
            font-weight: 700;
            color: #000;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            transition: color 0.3s ease;
        }

        .hud-meter-value.critical {
            color: #cc0000;
        }

        .hud-meter-bar-container {
            height: 6px;
            background: #eee;
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid #ddd;
        }

        .hud-meter-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .hud-meter-bar.lubrication { background: #000; }
        .hud-meter-bar.lubrication.critical { background: #cc0000; }
        .hud-meter-bar.heat { background: #000; }
        .hud-meter-bar.heat.critical { background: #cc0000; }
        .hud-meter-bar.warping { background: #000; }
        .hud-meter-bar.warping.critical { background: #cc0000; }

        /* ==================== OVERLAY SYSTEM ==================== */
        
        .overlay-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 20;
        }

        .countdown-number {
            font-size: clamp(120px, 35vw, 250px);
            font-weight: 900;
            color: #cc0000;
            opacity: 0;
            transform: scale(2);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            position: absolute;
            text-shadow: 
                -3px -3px 0 #fff, 3px -3px 0 #fff, -3px 3px 0 #fff, 3px 3px 0 #fff,
                -3px 0 0 #fff, 3px 0 0 #fff, 0 -3px 0 #fff, 0 3px 0 #fff,
                0 0 40px rgba(204, 0, 0, 0.6), 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .countdown-number.visible {
            animation: countdownPulse 1s ease-out forwards;
        }

        @keyframes countdownPulse {
            0% { transform: scale(2); opacity: 0; }
            15% { transform: scale(1); opacity: 1; }
            85% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0; }
        }

        .success-checkmark {
            font-size: clamp(100px, 30vw, 200px);
            color: #00aa44;
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
            position: absolute;
            text-shadow: 
                -3px -3px 0 #fff, 3px -3px 0 #fff, -3px 3px 0 #fff, 3px 3px 0 #fff,
                -3px 0 0 #fff, 3px 0 0 #fff, 0 -3px 0 #fff, 0 3px 0 #fff,
                0 0 40px rgba(0, 170, 68, 0.6), 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .success-checkmark.visible {
            animation: checkmarkPop 1.2s ease-out forwards;
        }

        @keyframes checkmarkPop {
            0% { transform: scale(0.5); opacity: 0; }
            20% { transform: scale(1.2); opacity: 1; }
            40% { transform: scale(1); opacity: 1; }
            80% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0; }
        }

        .warning-flash-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(204, 0, 0, 0.12);
            pointer-events: none;
            opacity: 0;
            z-index: 15;
        }

        .warning-flash-overlay.active {
            animation: flashWarning 0.3s ease-out;
        }

        @keyframes flashWarning {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .success-flash-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 170, 68, 0.15);
            pointer-events: none;
            opacity: 0;
            z-index: 15;
        }

        .success-flash-overlay.active {
            animation: flashSuccess 0.4s ease-out;
        }

        @keyframes flashSuccess {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .info-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.75);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 25;
        }

        .info-overlay.visible {
            opacity: 1;
            pointer-events: auto;
            cursor: pointer;
        }

        .info-overlay-content {
            background: #fff;
            padding: clamp(16px, 4vw, 40px) clamp(20px, 5vw, 50px);
            border: 3px solid #000;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            width: clamp(240px, 70%, 450px);
        }

        .info-overlay.damage-mode .info-overlay-content {
            border-color: #cc0000;
        }

        .info-overlay-title {
            font-size: clamp(16px, 4vw, 28px);
            margin-bottom: 8px;
            color: #000;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-overlay.damage-mode .info-overlay-title {
            color: #cc0000;
        }

        .info-overlay-stage {
            font-size: clamp(12px, 3vw, 20px);
            font-weight: 700;
            color: #000;
            margin-bottom: 12px;
        }

        .info-overlay.damage-mode .info-overlay-stage {
            color: #cc0000;
        }

        .info-overlay-description {
            font-size: clamp(10px, 2.5vw, 14px);
            color: #333;
            line-height: 1.5;
            margin-bottom: 16px;
            text-align: left;
        }

        .info-overlay-tap {
            font-size: clamp(9px, 2vw, 12px);
            color: #888;
            font-style: italic;
        }

        /* ==================== TUTORIAL SYSTEM ==================== */
        
        .tutorial-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 100;
            display: none;
            cursor: pointer;
        }

        .tutorial-overlay.active {
            display: block;
        }

        .tutorial-spotlight {
            position: absolute;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            pointer-events: none;
            transition: all 0.4s ease;
        }

        .tutorial-arrow-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.4s ease;
        }

        .tutorial-arrow-container.position-below { flex-direction: column; }
        .tutorial-arrow-container.position-above { flex-direction: column-reverse; }
        .tutorial-arrow-container.position-left { flex-direction: row-reverse; }
        .tutorial-arrow-container.position-right { flex-direction: row; }

        .tutorial-arrow {
            font-size: 60px;
            font-weight: 900;
            color: #000;
            line-height: 1;
            text-shadow: 
                -2px -2px 0 #fff, 2px -2px 0 #fff, -2px 2px 0 #fff, 2px 2px 0 #fff,
                -2px 0 0 #fff, 2px 0 0 #fff, 0 -2px 0 #fff, 0 2px 0 #fff,
                0 0 10px rgba(255, 255, 255, 0.8);
        }

        .tutorial-arrow-container.position-below .tutorial-arrow { animation: arrowBounceDown 1s ease-in-out infinite; }
        .tutorial-arrow-container.position-above .tutorial-arrow { animation: arrowBounceUp 1s ease-in-out infinite; }
        .tutorial-arrow-container.position-left .tutorial-arrow { animation: arrowBounceLeft 1s ease-in-out infinite; }
        .tutorial-arrow-container.position-right .tutorial-arrow { animation: arrowBounceRight 1s ease-in-out infinite; }

        @keyframes arrowBounceDown { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(15px); } }
        @keyframes arrowBounceUp { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        @keyframes arrowBounceLeft { 0%, 100% { transform: translateX(0); } 50% { transform: translateX(-15px); } }
        @keyframes arrowBounceRight { 0%, 100% { transform: translateX(0); } 50% { transform: translateX(15px); } }

        .tutorial-text {
            background: #fff;
            padding: 12px 18px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #333;
            max-width: 250px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 2px solid #000;
        }

        .tutorial-text small {
            display: block;
            margin-top: 6px;
            font-size: 11px;
            color: #888;
        }

        .tutorial-progress {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 101;
        }

        .tutorial-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #000;
            transition: all 0.3s ease;
        }

        .tutorial-dot.active { background: #000; transform: scale(1.2); }
        .tutorial-dot.completed { background: #00aa44; border-color: #00aa44; }
        .tutorial-overlay.idle-hint .tutorial-progress { display: none; }

        /* Row 3: Oil Slider + Buttons */
        .oil-slider-row {
            display: flex;
            gap: 10px;
            align-items: stretch;
        }

        .oil-slider-container {
            flex: 1;
            background: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            padding: 10px 12px;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .oil-slider-container.warning {
            border-color: #cc0000;
            box-shadow: 0 0 15px rgba(204, 0, 0, 0.2);
        }

        .refill-oil-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(204, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            border-radius: 6px;
        }

        .refill-oil-overlay.active {
            animation: refillFlash 0.5s ease-in-out infinite;
        }

        @keyframes refillFlash {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 0.5; }
        }

        .refill-oil-text {
            color: #fff;
            font-size: clamp(16px, 4vw, 24px);
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .oil-slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .oil-slider-title {
            font-size: clamp(10px, 2.5vw, 12px);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .warning-icon {
            color: #cc0000;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .oil-percentage {
            font-size: clamp(18px, 5vw, 28px);
            font-weight: 700;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            transition: color 0.3s ease;
        }

        .oil-percentage.low { color: #cc0000; }

        .oil-slider-track-wrapper { position: relative; }

        .oil-slider-track {
            height: clamp(14px, 3vw, 20px);
            background: #e8e8e8;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            border: 1px solid #ccc;
        }

        .critical-line {
            position: absolute;
            left: 10%;
            top: -4px;
            bottom: -4px;
            width: 0;
            border-left: 2px dashed #cc0000;
            pointer-events: none;
            z-index: 2;
        }

        .check-oil-line {
            position: absolute;
            left: 25%;
            top: -4px;
            bottom: -4px;
            width: 0;
            border-left: 2px dashed #dd8800;
            pointer-events: none;
            z-index: 2;
        }

        .oil-slider-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #333, #000);
            border-radius: 9px;
            transition: width 0.1s ease;
        }

        .oil-slider-fill.low {
            background: linear-gradient(90deg, #cc0000, #ff4444);
        }

        .oil-slider-ball {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: clamp(24px, 6vw, 34px);
            height: clamp(24px, 6vw, 34px);
            background: #fff;
            border: 3px solid #000;
            border-radius: 50%;
            cursor: grab;
            transition: box-shadow 0.2s ease, border-color 0.3s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            z-index: 3;
        }

        .oil-slider-ball:hover { box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); }
        .oil-slider-ball:active { cursor: grabbing; }
        .oil-slider-ball.low { border-color: #cc0000; }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: clamp(8px, 2vw, 10px);
            color: #999;
            margin-top: 6px;
        }

        .buttons-container {
            display: flex;
            gap: 6px;
        }

        .refill-btn, .reset-btn {
            width: clamp(50px, 10vw, 80px);
            height: 100%;
            background: #000;
            color: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            font-size: clamp(8px, 2vw, 10px);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .refill-btn:hover, .reset-btn:hover { background: #333; border-color: #333; }
        .refill-btn:active, .reset-btn:active { background: #555; }
        .refill-btn .btn-icon, .reset-btn .btn-icon { font-size: clamp(16px, 4vw, 22px); }

        /* ==================== DESKTOP / LANDSCAPE ==================== */
        @media (min-width: 601px), (orientation: landscape) {
            .container { padding-left: 5%; padding-right: 5%; }
            .engine-canvas-wrapper { min-height: 390px; }
        }

        /* ==================== MOBILE PORTRAIT ==================== */
        @media (max-width: 600px) and (orientation: portrait) {
            .engine-canvas-wrapper { min-height: 36vh; }
            .hud-left-panel { left: 4px; width: clamp(80px, 22vw, 110px); }
            .hud-right-panel { right: 4px; width: clamp(70px, 20vw, 100px); }
            .tutorial-text { max-width: 250px; }
        }

        /* ==================== RESPONSIVE ==================== */
        @media (max-width: 500px) {
            .warning-lights-top { gap: 12px; }
            .warning-light { font-size: 9px; }
            .warning-light .indicator { width: 8px; height: 8px; }
            .hud-status { padding: 4px 6px; }
            .hud-status-stage { font-size: 9px; }
            .hud-problems { padding: 4px 6px; }
            .hud-problems-list li { font-size: 7px; }
            .hud-condition { padding: 4px 6px; }
            .hud-condition-text { font-size: 7px; }
            .hud-rpm { padding: 4px 6px; }
            .hud-rpm-value { font-size: 14px; }
            .hud-rpm-reduction { font-size: 7px; }
            .hud-meter-content { padding: 4px 6px; }
            .hud-meter-label { font-size: 6px; }
            .hud-meter-value { font-size: 8px; }
            .hud-meter-bar-container { height: 4px; }
            .hud-meter-warning { width: 12px; }
            .hud-meter-warning-icon { font-size: 8px; }
            .tutorial-text { font-size: 12px; padding: 10px 14px; }
            .tutorial-arrow { font-size: 45px; }
            .info-overlay-content { padding: 12px 16px; }
            .info-overlay-title { font-size: 14px; }
            .info-overlay-stage { font-size: 11px; }
            .info-overlay-description { font-size: 10px; }
            .buttons-container { gap: 4px; }
            .refill-btn, .reset-btn { width: clamp(45px, 12vw, 70px); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>V6 Engine Lubrication Simulation</h1>
            <p class="subtitle">Interactive demonstration of engine operation and oil system failure</p>
        </header>
        
        <div class="engine-canvas-wrapper" id="engineWrapper">
            <canvas id="engineCanvas"></canvas>
            
            <div class="warning-lights-top">
                <div class="warning-light" id="checkOilLight">
                    <span class="indicator"></span>
                    <span>Check Oil</span>
                </div>
                <div class="warning-light" id="checkEngineLight">
                    <span class="indicator"></span>
                    <span>Check Engine</span>
                </div>
            </div>
            
            <div class="hud-left-panel" id="hudLeftPanel">
                <div class="hud-status" id="hudStatus" data-info="status">
                    <div class="hud-status-label">Eng. Status</div>
                    <div class="hud-status-stage" id="damageStage">PERFECT</div>
                    <div class="hud-status-text" id="statusText">1: Nominal</div>
                </div>
                <div class="hud-problems" id="hudProblems" data-info="problems">
                    <ul class="hud-problems-list" id="problemsList"></ul>
                </div>
                <div class="hud-condition" id="hudCondition" data-info="condition">
                    <div class="hud-condition-text" id="conditionText">Engine running at peak performance.</div>
                </div>
            </div>
            
            <div class="hud-right-panel" id="hudRightPanel">
                <div class="hud-rpm" id="hudRpm" data-info="rpm">
                    <div class="hud-rpm-label">RPM</div>
                    <div class="hud-rpm-value-container">
                        <div class="hud-rpm-value" id="engineRPM">3000</div>
                        <div class="hud-rpm-reduction" id="rpmReduction">-0%</div>
                    </div>
                </div>
                <div class="hud-meters">
                    <div class="hud-meter" id="lubMeterContainer" data-info="lube">
                        <div class="hud-meter-warning"><span class="hud-meter-warning-icon">‚ö†</span></div>
                        <div class="hud-meter-content">
                            <div class="hud-meter-header">
                                <span class="hud-meter-label">Lube</span>
                                <span class="hud-meter-value" id="lubValue">100%</span>
                            </div>
                            <div class="hud-meter-bar-container">
                                <div class="hud-meter-bar lubrication" id="lubMeter" style="width: 100%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="hud-meter" id="heatMeterContainer" data-info="heat">
                        <div class="hud-meter-warning"><span class="hud-meter-warning-icon">‚ö†</span></div>
                        <div class="hud-meter-content">
                            <div class="hud-meter-header">
                                <span class="hud-meter-label">Heat</span>
                                <span class="hud-meter-value" id="heatValue">0%</span>
                            </div>
                            <div class="hud-meter-bar-container">
                                <div class="hud-meter-bar heat" id="heatMeter" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="hud-meter" id="warpMeterContainer" data-info="warp">
                        <div class="hud-meter-warning"><span class="hud-meter-warning-icon">‚ö†</span></div>
                        <div class="hud-meter-content">
                            <div class="hud-meter-header">
                                <span class="hud-meter-label">Mtl. Warp</span>
                                <span class="hud-meter-value" id="warpValue">0%</span>
                            </div>
                            <div class="hud-meter-bar-container">
                                <div class="hud-meter-bar warping" id="warpMeter" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="overlay-container">
                <div class="countdown-number" id="countdownNumber">3</div>
                <div class="success-checkmark" id="successCheckmark">‚úì</div>
            </div>
            <div class="warning-flash-overlay" id="warningFlash"></div>
            <div class="success-flash-overlay" id="successFlash"></div>
            <div class="info-overlay" id="infoOverlay">
                <div class="info-overlay-content">
                    <div class="info-overlay-title" id="infoOverlayTitle">‚ö† Engine Damage</div>
                    <div class="info-overlay-stage" id="infoOverlayStage">Stage 2: WEAR</div>
                    <div class="info-overlay-description" id="infoOverlayDescription"></div>
                    <div class="info-overlay-tap">Tap anywhere to continue</div>
                </div>
            </div>
        </div>
        
        <div class="oil-slider-row" id="oilSliderRow">
            <div class="oil-slider-container" id="oilSection">
                <div class="refill-oil-overlay" id="refillOilOverlay">
                    <span class="refill-oil-text">‚ö† REFILL OIL ‚ö†</span>
                </div>
                <div class="oil-slider-header">
                    <div class="oil-slider-title">
                        Oil Level
                        <span class="warning-icon" id="oilWarningIcon" style="display: none;">‚ö†</span>
                    </div>
                    <div class="oil-percentage" id="oilPercentage"><span id="oilPercent">100</span>%</div>
                </div>
                <div class="oil-slider-track-wrapper">
                    <div class="critical-line"></div>
                    <div class="check-oil-line"></div>
                    <div class="oil-slider-track" id="oilSliderTrack">
                        <div class="oil-slider-fill" id="oilSliderFill"></div>
                        <div class="oil-slider-ball" id="oilSliderBall"></div>
                    </div>
                </div>
                <div class="slider-labels">
                    <span>Empty</span>
                    <span>Full</span>
                </div>
            </div>
            <div class="buttons-container" id="buttonsContainer">
                <button class="refill-btn" id="refillBtn">
                    <span class="btn-icon">üõ¢Ô∏è</span>
                    <span>Refill</span>
                </button>
                <button class="reset-btn" id="resetBtn">
                    <span class="btn-icon">‚öôÔ∏è</span>
                    <span>Reset</span>
                </button>
            </div>
        </div>
    </div>
    
    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-spotlight" id="tutorialSpotlight"></div>
        <div class="tutorial-arrow-container" id="tutorialArrowContainer">
            <div class="tutorial-arrow" id="tutorialArrow">‚ñº</div>
            <div class="tutorial-text" id="tutorialText">
                Tutorial text here
                <small>Tap to continue</small>
            </div>
        </div>
        <div class="tutorial-progress" id="tutorialProgress"></div>
    </div>

    <script>
        // ==================== CANVAS SETUP ====================
        const canvas = document.getElementById('engineCanvas');
        const ctx = canvas.getContext('2d');
        const engineWrapper = document.getElementById('engineWrapper');
        
        const CANVAS_WIDTH = 1040;
        const CANVAS_HEIGHT = 520;
        const ENGINE_CENTER_X = 520;
        const ENGINE_CENTER_Y = 280;
        
        function resizeCanvas() {
            const rect = engineWrapper.getBoundingClientRect();
            const containerWidth = rect.width;
            const containerHeight = rect.height;
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = containerHeight + 'px';
            const dpr = window.devicePixelRatio || 1;
            canvas.width = containerWidth * dpr;
            canvas.height = containerHeight * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // ==================== ZOOM STATE ====================
        const zoom = {
            level: 1,
            targetLevel: 1,
            offsetX: 0,
            offsetY: 0,
            targetOffsetX: 0,
            targetOffsetY: 0,
            isZoomed: false,
            baseScale: 1.035,
            zoomedScale: 1.6
        };
        
        // ==================== ENGINE STATE ====================
        const engine = {
            oilLevel: 100,
            lubrication: 100,
            heat: 0,
            warping: 0,
            damageStage: 0,
            rpm: 3000,
            crankAngle: 0,
            isRunning: true,
            countdownActive: false,
            countdownValue: 3,
            countdownTimer: null,
            damagePopupVisible: false,
            infoPopupVisible: false,
            graceActive: false,
            frictionParticles: [],
            windageParticles: [],
            drainbackParticles: [],
            warpAppliedAtStage: -1,
            statsFrozen: false,
            rpmReductionPercent: 0,
            galleryFlowOffset: 0,
            pumpSuckingAir: false
        };
        
        const warpIncrements = [0, 5, 10, 18, 30, 50];
        
        const damageEffects = [
            { lubeLossMult: 1.0, heatMult: 1.0 },
            { lubeLossMult: 1.3, heatMult: 1.3 },
            { lubeLossMult: 1.6, heatMult: 1.6 },
            { lubeLossMult: 2.0, heatMult: 2.0 },
            { lubeLossMult: 2.5, heatMult: 2.5 },
            { lubeLossMult: 3.0, heatMult: 3.0 }
        ];
        
        const stageProblems = [
            [],
            ["-13% RPMs"],
            ["-27% RPMs", "more friction"],
            ["-40% RPMs", "high friction", "metal warped"],
            ["-53% RPMs", "major friction", "severe warping"],
            ["replace engine"]
        ];
        
        const stageConditions = [
            "Engine running at peak performance.",
            "Minor wear detected, efficiency slightly reduced.",
            "Bearing damage causing increased friction.",
            "Cylinder scoring with significant metal warping.",
            "Severe internal damage, failure imminent.",
            "Engine has seized. Replacement required."
        ];
        
        const damageDescriptions = [
            "",
            "<b>Surface wear</b> has formed on cylinder walls from excessive friction. You'll notice <b>reduced RPM capacity</b> and the engine will have a harder time maintaining lubrication.",
            "<b>Main bearings are damaged</b> from heat stress. Friction is now <b>significantly higher</b>, making it harder for oil to properly lubricate moving parts. Heat will build up faster.",
            "<b>Deep scoring marks</b> have formed on cylinder walls from metal-to-metal contact. <b>Permanent metal warping</b> has begun. The engine struggles to maintain safe operating temperatures.",
            "<b>Severe internal damage</b> throughout the engine. Connecting rods and crankshaft bearings are <b>compromised</b>. The engine can barely function and will fail completely without immediate intervention.",
            "The engine has <b>completely seized</b>. Pistons have welded to cylinder walls due to extreme heat and lack of lubrication. The engine <b>cannot be repaired</b> and must be replaced."
        ];
        
        const damageStages = [
            { name: "PERFECT", description: "1: Nominal", color: "" },
            { name: "WEAR", description: "2: Wear", color: "stage-1" },
            { name: "BEARING", description: "3: Damage", color: "stage-2" },
            { name: "SCORING", description: "4: Cylinder", color: "stage-3" },
            { name: "CRITICAL", description: "5: Severe", color: "stage-4" },
            { name: "SEIZED", description: "6: Failed", color: "stage-5" }
        ];
        
        const infoContent = {
            rpm: { title: "RPM Meter", description: "<b>RPM (Revolutions Per Minute)</b> shows how fast the engine crankshaft is spinning. Higher damage stages <b>reduce maximum RPM</b> as the engine loses efficiency due to increased friction and mechanical resistance." },
            lube: { title: "Lubrication Meter", description: "<b>Lubrication</b> indicates how well oil is coating the engine's moving parts. When oil level drops <b>below 10%</b>, the pump pickup sucks air instead of oil, causing lubrication to fail rapidly." },
            heat: { title: "Heat Meter", description: "<b>Heat</b> measures dangerous friction-generated temperature in the engine. Heat starts building when lubrication drops <b>below 50%</b>. At <b>90% heat</b>, the countdown to engine damage begins." },
            warp: { title: "Metal Warping Meter", description: "<b>Metal Warping</b> shows permanent physical damage to engine components. This <b>cannot be reversed</b> without a full engine reset. High warping causes pistons to become misaligned." },
            status: { title: "Engine Status", description: "<b>Engine Status</b> displays the current damage stage from <b>1 (Perfect)</b> to <b>6 (Seized)</b>. Each damage stage permanently reduces engine performance and increases vulnerability to further damage." },
            problems: { title: "Current Problems", description: "This panel lists <b>active issues</b> affecting engine performance. Problems accumulate as damage stages increase, showing <b>RPM reduction</b>, friction levels, and warping status." },
            condition: { title: "Engine Condition", description: "A <b>brief summary</b> of the engine's overall health and operational status. This description changes based on the current <b>damage stage</b> and explains what's happening internally." }
        };
        
        // ==================== DOM ELEMENTS ====================
        const oilSliderTrack = document.getElementById('oilSliderTrack');
        const oilSliderFill = document.getElementById('oilSliderFill');
        const oilSliderBall = document.getElementById('oilSliderBall');
        const oilPercent = document.getElementById('oilPercent');
        const oilPercentage = document.getElementById('oilPercentage');
        const oilSection = document.getElementById('oilSection');
        const oilWarningIcon = document.getElementById('oilWarningIcon');
        const refillOilOverlay = document.getElementById('refillOilOverlay');
        const lubMeter = document.getElementById('lubMeter');
        const lubValue = document.getElementById('lubValue');
        const lubMeterContainer = document.getElementById('lubMeterContainer');
        const heatMeter = document.getElementById('heatMeter');
        const heatValue = document.getElementById('heatValue');
        const heatMeterContainer = document.getElementById('heatMeterContainer');
        const warpMeter = document.getElementById('warpMeter');
        const warpValue = document.getElementById('warpValue');
        const warpMeterContainer = document.getElementById('warpMeterContainer');
        const damageStageEl = document.getElementById('damageStage');
        const statusText = document.getElementById('statusText');
        const hudStatus = document.getElementById('hudStatus');
        const hudProblems = document.getElementById('hudProblems');
        const problemsList = document.getElementById('problemsList');
        const hudCondition = document.getElementById('hudCondition');
        const conditionText = document.getElementById('conditionText');
        const countdownNumber = document.getElementById('countdownNumber');
        const successCheckmark = document.getElementById('successCheckmark');
        const warningFlash = document.getElementById('warningFlash');
        const successFlash = document.getElementById('successFlash');
        const infoOverlay = document.getElementById('infoOverlay');
        const infoOverlayTitle = document.getElementById('infoOverlayTitle');
        const infoOverlayStage = document.getElementById('infoOverlayStage');
        const infoOverlayDescription = document.getElementById('infoOverlayDescription');
        const resetBtn = document.getElementById('resetBtn');
        const refillBtn = document.getElementById('refillBtn');
        const engineRPM = document.getElementById('engineRPM');
        const rpmReduction = document.getElementById('rpmReduction');
        const checkOilLight = document.getElementById('checkOilLight');
        const checkEngineLight = document.getElementById('checkEngineLight');
        
        // ==================== INFO POPUP SYSTEM ====================
        function showInfoPopup(infoKey) {
            if (engine.countdownActive || engine.damagePopupVisible) return;
            const info = infoContent[infoKey];
            if (!info) return;
            engine.infoPopupVisible = true;
            engine.statsFrozen = true;
            infoOverlay.classList.remove('damage-mode');
            infoOverlayTitle.textContent = info.title;
            infoOverlayStage.style.display = 'none';
            infoOverlayDescription.innerHTML = info.description;
            infoOverlay.classList.add('visible');
        }
        
        function showDamagePopup() {
            engine.damagePopupVisible = true;
            engine.statsFrozen = true;
            infoOverlay.classList.add('damage-mode');
            infoOverlayTitle.textContent = '‚ö† Engine Damage';
            infoOverlayStage.style.display = 'block';
            infoOverlayStage.textContent = `Stage ${engine.damageStage + 1}: ${damageStages[engine.damageStage].name}`;
            infoOverlayDescription.innerHTML = damageDescriptions[engine.damageStage];
            infoOverlay.classList.add('visible');
            refillOilOverlay.classList.remove('active');
            warningFlash.classList.remove('active');
            void warningFlash.offsetWidth;
            warningFlash.classList.add('active');
        }
        
        function hideInfoOverlay() {
            infoOverlay.classList.remove('visible');
            if (engine.damagePopupVisible) {
                engine.damagePopupVisible = false;
                engine.statsFrozen = false;
                engine.graceActive = true;
                setTimeout(() => {
                    engine.graceActive = false;
                    if (engine.heat > 90 && engine.damageStage < 5 && !engine.countdownActive) startCountdown();
                }, 2000);
            } else if (engine.infoPopupVisible) {
                engine.infoPopupVisible = false;
                engine.statsFrozen = false;
            }
        }
        
        infoOverlay.addEventListener('click', hideInfoOverlay);
        document.querySelectorAll('[data-info]').forEach(el => {
            el.addEventListener('click', (e) => { e.stopPropagation(); showInfoPopup(el.dataset.info); });
        });
        
        // ==================== ZOOM INTERACTION ====================
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
            else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
            else { clientX = e.clientX; clientY = e.clientY; }
            return { relX: (clientX - rect.left) / rect.width, relY: (clientY - rect.top) / rect.height };
        }
        
        function handleZoomTap(e) {
            if (engine.damagePopupVisible || engine.infoPopupVisible || tutorialActive || idleHintActive) return;
            e.preventDefault();
            const coords = getCanvasCoordinates(e);
            if (zoom.isZoomed) {
                zoom.isZoomed = false;
                zoom.targetLevel = zoom.baseScale;
                zoom.targetOffsetX = 0;
                zoom.targetOffsetY = 0;
                canvas.classList.remove('zoomed');
            } else {
                zoom.isZoomed = true;
                zoom.targetLevel = zoom.zoomedScale;
                canvas.classList.add('zoomed');
                const dx = (coords.relX - 0.5) * 2;
                const dy = (coords.relY - 0.5) * 2;
                const maxOffset = 150;
                zoom.targetOffsetX = -dx * maxOffset;
                zoom.targetOffsetY = -dy * maxOffset;
            }
        }
        
        canvas.addEventListener('click', handleZoomTap);
        canvas.addEventListener('touchend', (e) => { if (e.cancelable) e.preventDefault(); handleZoomTap(e); }, { passive: false });
        
        function updateZoom() {
            const smoothing = 0.12;
            zoom.level += (zoom.targetLevel - zoom.level) * smoothing;
            zoom.offsetX += (zoom.targetOffsetX - zoom.offsetX) * smoothing;
            zoom.offsetY += (zoom.targetOffsetY - zoom.offsetY) * smoothing;
        }
        
        // ==================== TUTORIAL SYSTEM ====================
        const tutorialOverlay = document.getElementById('tutorialOverlay');
        const tutorialSpotlight = document.getElementById('tutorialSpotlight');
        const tutorialArrowContainer = document.getElementById('tutorialArrowContainer');
        const tutorialArrow = document.getElementById('tutorialArrow');
        const tutorialText = document.getElementById('tutorialText');
        const tutorialProgress = document.getElementById('tutorialProgress');
        
        const tutorialSteps = [
            { target: 'oilSection', position: 'above', text: '<b>Drag this slider</b> to control the <b>oil level</b>. Low oil causes engine damage!' },
            { target: 'hudRightPanel', position: 'left', text: 'Monitor <b>engine stats</b> here: <b>RPM</b>, <b>lubrication</b>, <b>heat</b>, and <b>metal warping</b>.' },
            { target: 'buttonsContainer', position: 'above', text: 'Use <b>Refill</b> to add oil, or <b>Reset</b> to restore the engine to <b>perfect condition</b>.' }
        ];
        
        let currentTutorialStep = 0, tutorialAutoTimer = null, tutorialActive = false, tutorialCompleted = false;
        let idleTimer = null, idleHintActive = false;
        const IDLE_TIMEOUT = 15000;
        
        function resetIdleTimer() {
            if (idleTimer) clearTimeout(idleTimer);
            if (idleHintActive) hideIdleHint();
            if (tutorialCompleted && !tutorialActive && !engine.countdownActive && !engine.damagePopupVisible && !engine.infoPopupVisible)
                idleTimer = setTimeout(showIdleHint, IDLE_TIMEOUT);
        }
        
        function showIdleHint() {
            if (tutorialActive || engine.countdownActive || engine.damagePopupVisible || engine.infoPopupVisible) return;
            idleHintActive = true;
            tutorialOverlay.classList.add('active', 'idle-hint');
            const targetEl = document.getElementById('oilSection');
            const rect = targetEl.getBoundingClientRect();
            tutorialSpotlight.style.left = (rect.left - 8) + 'px';
            tutorialSpotlight.style.top = (rect.top - 8) + 'px';
            tutorialSpotlight.style.width = (rect.width + 16) + 'px';
            tutorialSpotlight.style.height = (rect.height + 16) + 'px';
            tutorialArrow.textContent = '‚ñº';
            tutorialArrowContainer.className = 'tutorial-arrow-container position-above';
            const arrowX = rect.left + rect.width / 2;
            const arrowY = rect.top - 8;
            tutorialArrowContainer.style.left = arrowX + 'px';
            tutorialArrowContainer.style.top = arrowY + 'px';
            tutorialArrowContainer.style.transform = 'translate(-50%, -100%)';
            tutorialText.innerHTML = '<b>Move oil level slider</b> to affect the engine<small>Tap to dismiss</small>';
        }
        
        function hideIdleHint() { idleHintActive = false; tutorialOverlay.classList.remove('active', 'idle-hint'); }
        function handleUserInteraction() { resetIdleTimer(); }
        
        ['mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend', 'keydown', 'keyup', 'scroll', 'wheel', 'click'].forEach(evt => 
            document.addEventListener(evt, handleUserInteraction));
        
        function startTutorial() {
            tutorialActive = true; tutorialCompleted = false; currentTutorialStep = 0;
            tutorialOverlay.classList.add('active'); tutorialOverlay.classList.remove('idle-hint');
            tutorialProgress.innerHTML = '';
            tutorialSteps.forEach((_, i) => {
                const dot = document.createElement('div');
                dot.className = 'tutorial-dot' + (i === 0 ? ' active' : '');
                tutorialProgress.appendChild(dot);
            });
            showTutorialStep(0);
        }
        
        function showTutorialStep(stepIndex) {
            if (stepIndex >= tutorialSteps.length) { endTutorial(); return; }
            const step = tutorialSteps[stepIndex];
            const targetEl = document.getElementById(step.target);
            const rect = targetEl.getBoundingClientRect();
            tutorialSpotlight.style.left = (rect.left - 8) + 'px';
            tutorialSpotlight.style.top = (rect.top - 8) + 'px';
            tutorialSpotlight.style.width = (rect.width + 16) + 'px';
            tutorialSpotlight.style.height = (rect.height + 16) + 'px';
            const arrows = { below: '‚ñ≤', above: '‚ñº', left: '‚ñ∂', right: '‚óÄ' };
            tutorialArrow.textContent = arrows[step.position];
            tutorialArrowContainer.className = 'tutorial-arrow-container position-' + step.position;
            let arrowX, arrowY;
            switch (step.position) {
                case 'below': arrowX = rect.left + rect.width / 2; arrowY = rect.bottom + 8; tutorialArrowContainer.style.transform = 'translate(-50%, 0)'; break;
                case 'above': arrowX = rect.left + rect.width / 2; arrowY = rect.top - 8; tutorialArrowContainer.style.transform = 'translate(-50%, -100%)'; break;
                case 'left': arrowX = rect.left - 8; arrowY = rect.top + rect.height / 2; tutorialArrowContainer.style.transform = 'translate(-100%, -50%)'; break;
                case 'right': arrowX = rect.right + 8; arrowY = rect.top + rect.height / 2; tutorialArrowContainer.style.transform = 'translate(0, -50%)'; break;
            }
            tutorialArrowContainer.style.left = arrowX + 'px';
            tutorialArrowContainer.style.top = arrowY + 'px';
            tutorialText.innerHTML = step.text + '<small>Tap to continue</small>';
            const dots = tutorialProgress.querySelectorAll('.tutorial-dot');
            dots.forEach((dot, i) => { dot.classList.remove('active', 'completed'); if (i < stepIndex) dot.classList.add('completed'); else if (i === stepIndex) dot.classList.add('active'); });
            if (tutorialAutoTimer) clearTimeout(tutorialAutoTimer);
            tutorialAutoTimer = setTimeout(advanceTutorial, 5000);
        }
        
        function advanceTutorial() { if (!tutorialActive) return; currentTutorialStep++; if (currentTutorialStep >= tutorialSteps.length) endTutorial(); else showTutorialStep(currentTutorialStep); }
        function endTutorial() { tutorialActive = false; tutorialCompleted = true; tutorialOverlay.classList.remove('active'); if (tutorialAutoTimer) clearTimeout(tutorialAutoTimer); resetIdleTimer(); }
        
        tutorialOverlay.addEventListener('click', () => { if (idleHintActive) hideIdleHint(); else advanceTutorial(); });
        tutorialArrowContainer.addEventListener('click', (e) => { e.stopPropagation(); if (idleHintActive) hideIdleHint(); else advanceTutorial(); });
        window.addEventListener('load', () => setTimeout(startTutorial, 500));
        
        // ==================== PARTICLE CLASSES ====================
        
        // Friction particles (smoke/sparks from cylinder walls)
        class FrictionParticle {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                if (type === 'smoke') {
                    this.vx = (Math.random() - 0.5) * 0.5;
                    this.vy = -Math.random() * 0.8 - 0.2;
                    this.life = 1.0; this.decay = 0.015;
                    this.size = 1 + Math.random() * 1.5;
                } else if (type === 'flash') {
                    this.vx = (Math.random() - 0.5) * 3;
                    this.vy = (Math.random() - 0.5) * 5;
                    this.life = 1.0; this.decay = 0.12;
                    this.size = 4 + Math.random() * 4;
                    this.colorPhase = Math.random() * 0.3;
                } else {
                    this.vx = (Math.random() - 0.5) * 4;
                    this.vy = (Math.random() - 0.5) * 8;
                    this.life = 1.0; this.decay = 0.08;
                    this.size = 2 + Math.random() * 3;
                }
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                if (this.type === 'smoke') { this.vx *= 0.95; this.vy *= 0.95; this.size += 0.06; }
                else if (this.type === 'flash') { this.colorPhase = Math.min(1, this.colorPhase + 0.15); }
                else { this.vy += 0.25; }
                this.life -= this.decay;
                return this.life > 0;
            }
            draw(ctx) {
                if (this.type === 'smoke') {
                    ctx.fillStyle = `rgba(140, 140, 140, ${this.life * 0.6})`;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                } else if (this.type === 'flash') {
                    const r = 255, g = Math.floor(255 * (1 - this.colorPhase)), b = g;
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${this.life})`;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.life * 0.8})`;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size * this.life * 0.4, 0, Math.PI * 2); ctx.fill();
                } else {
                    const brightness = 220 + Math.random() * 35;
                    ctx.fillStyle = `rgba(${brightness}, ${brightness * 0.4}, 0, ${this.life})`;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                }
            }
        }
        
        // Windage particles - oil flung from rotating crankshaft
        class WindageParticle {
            constructor(cx, cy, angle, speed) {
                this.x = cx; this.y = cy;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = 0.02 + Math.random() * 0.01;
                this.size = 1.5 + Math.random() * 1.5;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.15; // gravity
                this.life -= this.decay;
                return this.life > 0;
            }
            draw(ctx) {
                ctx.fillStyle = `rgba(0, 0, 0, ${this.life * 0.6})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Drainback particles - oil dripping back to pan by gravity
        class DrainbackParticle {
            constructor(x, y) {
                this.x = x + (Math.random() - 0.5) * 20;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = 0.5 + Math.random() * 1;
                this.life = 1.0;
                this.decay = 0.008;
                this.size = 2 + Math.random() * 2;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1; // gravity
                this.life -= this.decay;
                // Remove when below oil pan
                if (this.y > 470) return false;
                return this.life > 0;
            }
            draw(ctx) {
                ctx.fillStyle = `rgba(0, 0, 0, ${this.life * 0.5})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Air bubble particle for when pump sucks air
        class AirBubble {
            constructor(x, y) {
                this.x = x + (Math.random() - 0.5) * 10;
                this.y = y;
                this.vy = -1 - Math.random() * 2;
                this.life = 1.0;
                this.decay = 0.03;
                this.size = 2 + Math.random() * 3;
            }
            update() {
                this.y += this.vy;
                this.x += Math.sin(this.y * 0.1) * 0.5;
                this.life -= this.decay;
                return this.life > 0;
            }
            draw(ctx) {
                ctx.strokeStyle = `rgba(200, 200, 200, ${this.life * 0.8})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // ==================== CYLINDER CLASS ====================
        class Cylinder {
            constructor(x, y, angle, phaseOffset, bank, index) {
                this.x = x; this.y = y;
                this.baseAngle = angle; this.angle = angle;
                this.phaseOffset = phaseOffset;
                this.bank = bank; this.index = index;
                this.pistonPos = 0; this.prevPistonPos = 0;
                this.pistonWarpAngle = 0;
                this.intakeValveOpen = 0; this.exhaustValveOpen = 0;
                this.strokePhase = 0;
            }
            update(crankAngle, rpmReductionPercent) {
                const adjustedAngle = (crankAngle + this.phaseOffset) % 720;
                this.prevPistonPos = this.pistonPos;
                this.pistonPos = Math.sin((adjustedAngle * Math.PI) / 360) * 35;
                this.strokePhase = Math.floor(adjustedAngle / 180);
                const warpAngle = 10 * (rpmReductionPercent / 100);
                const warpDirection = (this.index % 2 === 0) ? 1 : -1;
                this.pistonWarpAngle = warpAngle * warpDirection;
                this.angle = this.baseAngle;
                if (adjustedAngle < 180) this.intakeValveOpen = Math.sin((adjustedAngle * Math.PI) / 180) * 12;
                else this.intakeValveOpen = 0;
                if (adjustedAngle >= 540) this.exhaustValveOpen = Math.sin(((adjustedAngle - 540) * Math.PI) / 180) * 12;
                else this.exhaustValveOpen = 0;
            }
            draw(ctx, engineState) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate((this.angle * Math.PI) / 180);
                const damageShake = engineState.damageStage > 2 ? (Math.random() - 0.5) * engineState.damageStage * 1.5 : 0;
                const damageLevel = engineState.damageStage;
                const heatLevel = engineState.heat;
                const lubeLevel = engineState.lubrication;
                let strokeColor = '#000', fillColor = '#fff', pistonFillColor = '#fff';
                if (heatLevel > 70) {
                    const glowIntensity = (heatLevel - 70) / 30;
                    pistonFillColor = `rgb(255, ${Math.floor(255 - glowIntensity * 200)}, ${Math.floor(255 - glowIntensity * 200)})`;
                }
                if (damageLevel >= 4) { strokeColor = '#880000'; fillColor = '#ffeeee'; }
                else if (damageLevel >= 2) { strokeColor = '#aa0000'; fillColor = '#fff8f8'; }
                else if (heatLevel > 70) { strokeColor = `rgb(${Math.floor(170 * (heatLevel - 70) / 30)}, 0, 0)`; }
                
                ctx.strokeStyle = strokeColor; ctx.fillStyle = fillColor; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.rect(-30 + damageShake, -90, 60, 130); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.rect(-35 + damageShake, -105, 70, 20); ctx.fill(); ctx.stroke();
                ctx.fillStyle = heatLevel > 60 ? '#fff0f0' : '#f5f5f5';
                ctx.beginPath(); ctx.rect(-25 + damageShake, -85, 50, 15); ctx.fill(); ctx.stroke();
                ctx.fillStyle = fillColor; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.rect(-20 + damageShake, -100 + this.intakeValveOpen, 6, 20); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(-17 + damageShake, -100 + this.intakeValveOpen, 8, 3, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.rect(14 + damageShake, -100 + this.exhaustValveOpen, 6, 20); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(17 + damageShake, -100 + this.exhaustValveOpen, 8, 3, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                
                const pistonY = this.pistonPos;
                ctx.save();
                ctx.translate(damageShake, pistonY + 7);
                ctx.rotate((this.pistonWarpAngle * Math.PI) / 180);
                ctx.fillStyle = pistonFillColor; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.rect(-25, -15, 50, 30); ctx.fill(); ctx.stroke();
                
                const lubeFactor = Math.max(0, (lubeLevel - 30) / 70);
                const lubeLineAlpha = Math.pow(lubeFactor, 1.5);
                if (lubeLineAlpha > 0.02) {
                    ctx.strokeStyle = `rgba(0, 0, 0, ${lubeLineAlpha})`;
                    ctx.lineWidth = 2 + lubeFactor * 4; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(-25, -12); ctx.lineTo(-25, 11); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(25, -12); ctx.lineTo(25, 11); ctx.stroke();
                    ctx.lineCap = 'butt';
                }
                ctx.strokeStyle = strokeColor; ctx.lineWidth = 1.5;
                for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.moveTo(-25, -9 + i * 8); ctx.lineTo(25, -9 + i * 8); ctx.stroke(); }
                ctx.fillStyle = fillColor; ctx.beginPath(); ctx.arc(0, 8, 5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.restore();
                
                ctx.lineWidth = 8; ctx.strokeStyle = fillColor;
                ctx.beginPath(); ctx.moveTo(damageShake, pistonY + 22); ctx.lineTo(damageShake, 68); ctx.stroke();
                ctx.lineWidth = 6; ctx.strokeStyle = strokeColor;
                ctx.beginPath(); ctx.moveTo(damageShake, pistonY + 22); ctx.lineTo(damageShake, 68); ctx.stroke();
                
                // Friction effects
                if (heatLevel > 60) {
                    const pistonMoving = Math.abs(this.pistonPos - this.prevPistonPos) > 0.5;
                    const frictionIntensity = (heatLevel - 60) / 40;
                    if (pistonMoving) {
                        for (let s = 0; s < 10; s++) {
                            if (Math.random() < frictionIntensity * 0.8) {
                                const sparkSide = Math.random() > 0.5 ? -25 : 25;
                                const sparkY = pistonY + (Math.random() - 0.5) * 28;
                                const rad = (this.angle * Math.PI) / 180;
                                const worldX = this.x + sparkSide * Math.cos(rad) - sparkY * Math.sin(rad);
                                const worldY = this.y + sparkSide * Math.sin(rad) + sparkY * Math.cos(rad);
                                engine.frictionParticles.push(new FrictionParticle(worldX, worldY, 'smoke'));
                            }
                        }
                        for (let f = 0; f < 2; f++) {
                            if (Math.random() < frictionIntensity * 0.6) {
                                const flashSide = Math.random() > 0.5 ? -25 : 25;
                                const flashY = pistonY + (Math.random() - 0.5) * 22;
                                const rad = (this.angle * Math.PI) / 180;
                                const worldX = this.x + flashSide * Math.cos(rad) - flashY * Math.sin(rad);
                                const worldY = this.y + flashSide * Math.sin(rad) + flashY * Math.cos(rad);
                                engine.frictionParticles.push(new FrictionParticle(worldX, worldY, 'flash'));
                            }
                        }
                        for (let sp = 0; sp < 3; sp++) {
                            if (Math.random() < frictionIntensity * 0.5) {
                                const sparkSide = Math.random() > 0.5 ? -25 : 25;
                                const sparkY = pistonY + (Math.random() - 0.5) * 25;
                                const rad = (this.angle * Math.PI) / 180;
                                const worldX = this.x + sparkSide * Math.cos(rad) - sparkY * Math.sin(rad);
                                const worldY = this.y + sparkSide * Math.sin(rad) + sparkY * Math.cos(rad);
                                engine.frictionParticles.push(new FrictionParticle(worldX, worldY, 'spark'));
                            }
                        }
                    }
                }
                
                if (heatLevel > 50) {
                    const heatLines = Math.floor((heatLevel - 50) / 10);
                    ctx.strokeStyle = `rgba(204, 0, 0, ${(heatLevel - 50) / 100})`;
                    ctx.lineWidth = 2; ctx.setLineDash([3, 3]);
                    for (let i = 0; i < heatLines; i++) {
                        ctx.beginPath(); ctx.moveTo(-38 + damageShake, -80 + i * 20); ctx.lineTo(-45 + damageShake, -80 + i * 20); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(38 + damageShake, -80 + i * 20); ctx.lineTo(45 + damageShake, -80 + i * 20); ctx.stroke();
                    }
                    ctx.setLineDash([]);
                }
                
                const strokeNames = ['IN', 'COMP', 'PWR', 'EXH'];
                ctx.fillStyle = strokeColor; ctx.font = 'bold 9px Helvetica'; ctx.textAlign = 'center';
                ctx.fillText(strokeNames[this.strokePhase], damageShake, -112);
                ctx.restore();
            }
        }
        
        // ==================== INITIALIZE CYLINDERS ====================
        const cylinders = [
            new Cylinder(320, 215, -30, 0, 'left', 0),
            new Cylinder(480, 215, -30, 240, 'left', 1),
            new Cylinder(640, 215, -30, 480, 'left', 2),
            new Cylinder(400, 215, 30, 120, 'right', 3),
            new Cylinder(560, 215, 30, 360, 'right', 4),
            new Cylinder(720, 215, 30, 600, 'right', 5),
        ];
        
        // ==================== OIL SYSTEM GEOMETRY ====================
        const oilSystem = {
            // Oil pan dimensions
            panX: 270, panY: 405, panWidth: 500, panHeight: 70,
            
            // Pickup tube location (extends into pan)
            pickupX: 320, pickupTopY: 410, pickupBottomY: 465,
            pickupScreenWidth: 25,
            
            // Oil pump location
            pumpX: 295, pumpY: 375, pumpWidth: 50, pumpHeight: 35,
            
            // Main gallery (horizontal, along bottom of block)
            mainGalleryY: 350,
            mainGalleryLeft: 290,
            mainGalleryRight: 750,
            
            // Vertical feeds to cylinders
            cylinderFeeds: [320, 400, 480, 560, 640, 720],
            feedTopY: 275,
            
            // Air bubbles when sucking air
            airBubbles: []
        };
        
        // ==================== DRAWING FUNCTIONS ====================
        function drawEngineBlock(ctx) {
            const damageLevel = engine.damageStage;
            let strokeColor = '#000', fillColor = '#fff';
            if (damageLevel >= 4) { strokeColor = '#880000'; fillColor = '#fff5f5'; }
            else if (damageLevel >= 2) { strokeColor = '#aa4444'; }
            ctx.strokeStyle = strokeColor; ctx.fillStyle = fillColor; ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(250, 320); ctx.lineTo(280, 150); ctx.lineTo(520, 115);
            ctx.lineTo(760, 150); ctx.lineTo(790, 320); ctx.lineTo(790, 365);
            ctx.lineTo(250, 365); ctx.closePath();
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = damageLevel >= 3 ? '#fff0f0' : '#f8f8f8';
            ctx.beginPath();
            ctx.moveTo(400, 175); ctx.lineTo(520, 145); ctx.lineTo(640, 175);
            ctx.lineTo(640, 250); ctx.lineTo(400, 250); ctx.closePath();
            ctx.fill(); ctx.stroke();
        }
        
        function drawCrankshaft(ctx, angle) {
            const centerX = 520, centerY = 345;
            const damageLevel = engine.damageStage;
            const shake = damageLevel > 2 ? (Math.random() - 0.5) * damageLevel * 2 : 0;
            let strokeColor = '#000';
            if (damageLevel >= 4) strokeColor = '#880000';
            else if (damageLevel >= 2) strokeColor = '#aa4444';
            
            ctx.save();
            ctx.translate(centerX + shake, centerY);
            ctx.rotate((angle * Math.PI) / 180);
            ctx.strokeStyle = strokeColor; ctx.fillStyle = '#fff'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(0, 0, 28, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.stroke();
            for (let i = 0; i < 6; i++) {
                const throwAngle = (i * 60 + 30) * Math.PI / 180;
                const throwX = Math.cos(throwAngle) * 45;
                const throwY = Math.sin(throwAngle) * 45;
                ctx.lineWidth = 10; ctx.strokeStyle = '#fff';
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(throwX * 0.75, throwY * 0.75); ctx.stroke();
                ctx.lineWidth = 8; ctx.strokeStyle = strokeColor;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(throwX * 0.75, throwY * 0.75); ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(throwX, throwY, 10, 0, Math.PI * 2); ctx.fill();
                ctx.lineWidth = 2; ctx.stroke();
            }
            ctx.restore();
            
            // Generate windage particles from spinning crankshaft
            if (engine.lubrication > 20 && engine.isRunning) {
                const rpmFactor = engine.rpm / 3000;
                if (Math.random() < 0.3 * rpmFactor) {
                    const throwAngle = (angle * Math.PI / 180) + Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3 * rpmFactor;
                    const startDist = 35 + Math.random() * 15;
                    const sx = centerX + Math.cos(throwAngle) * startDist;
                    const sy = centerY + Math.sin(throwAngle) * startDist;
                    engine.windageParticles.push(new WindageParticle(sx, sy, throwAngle, speed));
                }
            }
        }
        
        function drawOilPan(ctx) {
            const { panX, panY, panWidth, panHeight } = oilSystem;
            const oilLevel = engine.oilLevel;
            const isLowOil = oilLevel < 10;
            
            ctx.strokeStyle = isLowOil ? '#cc0000' : '#000';
            ctx.fillStyle = '#fff'; ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(panX, panY);
            ctx.lineTo(panX + 30, panY + panHeight);
            ctx.lineTo(panX + panWidth - 30, panY + panHeight);
            ctx.lineTo(panX + panWidth, panY);
            ctx.closePath();
            ctx.fill(); ctx.stroke();
            
            // Critical oil level line
            const criticalLineY = panY + panHeight - ((10 / 100) * (panHeight - 12)) - 5;
            ctx.strokeStyle = '#cc0000'; ctx.lineWidth = 1.5;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(panX + 40, criticalLineY);
            ctx.lineTo(panX + panWidth - 40, criticalLineY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw oil in pan
            const maxOilHeight = panHeight - 12;
            const oilHeight = (oilLevel / 100) * maxOilHeight;
            if (oilHeight > 0) {
                ctx.fillStyle = isLowOil ? '#cc0000' : '#000';
                const oilY = panY + panHeight - oilHeight - 5;
                const leftInset = 30 * (1 - oilHeight / panHeight);
                const rightInset = leftInset;
                ctx.beginPath();
                ctx.moveTo(panX + 35 + leftInset, oilY);
                ctx.lineTo(panX + panWidth - 35 - rightInset, oilY);
                ctx.lineTo(panX + panWidth - 35, panY + panHeight - 5);
                ctx.lineTo(panX + 35, panY + panHeight - 5);
                ctx.closePath();
                ctx.fill();
                
                // Oil surface waves
                ctx.strokeStyle = isLowOil ? '#ff6666' : '#333'; ctx.lineWidth = 1;
                const time = Date.now() / 400;
                ctx.beginPath();
                for (let x = panX + 40; x < panX + panWidth - 40; x += 3) {
                    const waveY = oilY + Math.sin(x / 15 + time) * 2;
                    if (x === panX + 40) ctx.moveTo(x, waveY);
                    else ctx.lineTo(x, waveY);
                }
                ctx.stroke();
            }
            
            // Oil level markers
            ctx.fillStyle = '#000'; ctx.font = '10px Helvetica'; ctx.textAlign = 'left';
            ctx.fillText('F', panX + panWidth + 10, panY + 15);
            ctx.fillText('E', panX + panWidth + 10, panY + panHeight - 5);
            
            // Drain plug
            ctx.fillStyle = '#fff'; ctx.strokeStyle = isLowOil ? '#cc0000' : '#000'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(panX + panWidth / 2, panY + panHeight, 6, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
        }
        
        function drawOilPumpAndPickup(ctx) {
            const { pickupX, pickupTopY, pickupBottomY, pickupScreenWidth, pumpX, pumpY, pumpWidth, pumpHeight, panY, panHeight } = oilSystem;
            const oilLevel = engine.oilLevel;
            const isLowOil = oilLevel < 10;
            const isFlowing = oilLevel >= 10 && engine.lubrication > 10;
            
            // Calculate oil surface Y position in pan
            const maxOilHeight = panHeight - 12;
            const oilHeight = (oilLevel / 100) * maxOilHeight;
            const oilSurfaceY = panY + panHeight - oilHeight - 5;
            
            // Pickup screen is below oil level check
            const pickupScreenY = pickupBottomY - 8;
            engine.pumpSuckingAir = pickupScreenY < oilSurfaceY;
            
            // Draw pickup tube
            ctx.strokeStyle = isLowOil ? '#cc0000' : '#000';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(pickupX, pickupTopY);
            ctx.lineTo(pickupX, pickupBottomY - 10);
            ctx.stroke();
            
            // Draw pickup screen (strainer)
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = isLowOil ? '#cc0000' : '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(pickupX - pickupScreenWidth/2, pickupBottomY - 15, pickupScreenWidth, 12, 3);
            ctx.fill();
            ctx.stroke();
            
            // Screen mesh pattern
            ctx.strokeStyle = isLowOil ? '#ffaaaa' : '#999';
            ctx.lineWidth = 0.5;
            for (let x = pickupX - pickupScreenWidth/2 + 3; x < pickupX + pickupScreenWidth/2 - 3; x += 4) {
                ctx.beginPath();
                ctx.moveTo(x, pickupBottomY - 13);
                ctx.lineTo(x, pickupBottomY - 5);
                ctx.stroke();
            }
            
            // Oil pump body
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = isLowOil ? '#cc0000' : '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(pumpX, pumpY, pumpWidth, pumpHeight, 4);
            ctx.fill();
            ctx.stroke();
            
            // Pump label
            ctx.fillStyle = isLowOil ? '#cc0000' : '#000';
            ctx.font = 'bold 8px Helvetica';
            ctx.textAlign = 'center';
            ctx.fillText('OIL', pumpX + pumpWidth/2, pumpY + 14);
            ctx.fillText('PUMP', pumpX + pumpWidth/2, pumpY + 24);
            
            // Pump inlet from pickup
            ctx.strokeStyle = isLowOil ? '#cc0000' : '#000';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(pickupX, pickupTopY);
            ctx.lineTo(pickupX, pumpY + pumpHeight);
            ctx.stroke();
            
            // If pump is sucking air, generate bubbles
            if (engine.pumpSuckingAir && engine.isRunning) {
                if (Math.random() < 0.3) {
                    oilSystem.airBubbles.push(new AirBubble(pickupX, pickupBottomY - 20));
                }
            }
        }
        
        function drawOilGalleries(ctx) {
            const { mainGalleryY, mainGalleryLeft, mainGalleryRight, cylinderFeeds, feedTopY, pumpX, pumpWidth, pumpY } = oilSystem;
            const isFlowing = engine.oilLevel >= 10 && engine.lubrication > 10;
            const flowAlpha = Math.min(1, engine.lubrication / 50);
            
            // Update flow animation offset
            if (isFlowing && engine.isRunning) {
                engine.galleryFlowOffset = (engine.galleryFlowOffset + 3) % 30;
            }
            
            // Gallery line properties
            const galleryWidth = isFlowing ? 6 : 4;
            
            // Draw main horizontal gallery
            if (isFlowing) {
                // Animated flowing gradient
                drawAnimatedGallery(ctx, 
                    [{x: pumpX + pumpWidth, y: pumpY + 10}, {x: pumpX + pumpWidth + 20, y: mainGalleryY}, {x: mainGalleryRight, y: mainGalleryY}],
                    galleryWidth, flowAlpha, true);
            } else {
                // Static gallery (no flow)
                ctx.strokeStyle = `rgba(150, 150, 150, 0.4)`;
                ctx.lineWidth = galleryWidth;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(pumpX + pumpWidth, pumpY + 10);
                ctx.lineTo(pumpX + pumpWidth + 20, mainGalleryY);
                ctx.lineTo(mainGalleryRight, mainGalleryY);
                ctx.stroke();
            }
            
            // Draw vertical feeds to each cylinder
            cylinderFeeds.forEach((feedX, i) => {
                if (isFlowing) {
                    drawAnimatedGallery(ctx,
                        [{x: feedX, y: mainGalleryY}, {x: feedX, y: feedTopY}],
                        galleryWidth - 1, flowAlpha, true);
                    
                    // Draw bearing indicator at top of feed
                    ctx.fillStyle = `rgba(0, 0, 0, ${flowAlpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(feedX, feedTopY, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.strokeStyle = `rgba(150, 150, 150, 0.4)`;
                    ctx.lineWidth = galleryWidth - 1;
                    ctx.beginPath();
                    ctx.moveTo(feedX, mainGalleryY);
                    ctx.lineTo(feedX, feedTopY);
                    ctx.stroke();
                }
            });
            
            // Generate drainback particles from cylinder areas
            if (isFlowing && engine.isRunning && Math.random() < 0.1) {
                const feedX = cylinderFeeds[Math.floor(Math.random() * cylinderFeeds.length)];
                engine.drainbackParticles.push(new DrainbackParticle(feedX, feedTopY + 50));
            }
        }
        
        function drawAnimatedGallery(ctx, points, width, alpha, showArrows) {
            const segmentLength = 30;
            const offset = engine.galleryFlowOffset;
            
            // Calculate total path length and draw segments
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Draw base gallery
            ctx.strokeStyle = `rgba(60, 60, 60, ${alpha})`;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
            
            // Draw animated flow segments
            let totalDist = 0;
            for (let i = 1; i < points.length; i++) {
                const p1 = points[i-1];
                const p2 = points[i];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const segDist = Math.sqrt(dx*dx + dy*dy);
                const angle = Math.atan2(dy, dx);
                
                // Draw flow pulses along this segment
                for (let d = (offset % segmentLength); d < segDist; d += segmentLength) {
                    const t = d / segDist;
                    const px = p1.x + dx * t;
                    const py = p1.y + dy * t;
                    
                    // Bright pulse
                    const pulseSize = width * 0.6;
                    const pulseAlpha = alpha * 0.8;
                    ctx.fillStyle = `rgba(30, 30, 30, ${pulseAlpha})`;
                    ctx.beginPath();
                    ctx.arc(px, py, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw direction arrow at midpoint
                if (showArrows && segDist > 40) {
                    const midX = p1.x + dx * 0.5;
                    const midY = p1.y + dy * 0.5;
                    drawFlowArrow(ctx, midX, midY, angle, alpha);
                }
                
                totalDist += segDist;
            }
        }
        
        function drawFlowArrow(ctx, x, y, angle, alpha) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
            ctx.beginPath();
            ctx.moveTo(6, 0);
            ctx.lineTo(-3, -4);
            ctx.lineTo(-3, 4);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        
        function drawParticles(ctx) {
            // Update and draw friction particles
            engine.frictionParticles = engine.frictionParticles.filter(p => p.update());
            engine.frictionParticles.forEach(p => p.draw(ctx));
            
            // Update and draw windage particles (crankshaft splash)
            engine.windageParticles = engine.windageParticles.filter(p => p.update());
            engine.windageParticles.forEach(p => p.draw(ctx));
            
            // Update and draw drainback particles
            engine.drainbackParticles = engine.drainbackParticles.filter(p => p.update());
            engine.drainbackParticles.forEach(p => p.draw(ctx));
            
            // Update and draw air bubbles
            oilSystem.airBubbles = oilSystem.airBubbles.filter(b => b.update());
            oilSystem.airBubbles.forEach(b => b.draw(ctx));
        }
        
        // ==================== ENGINE UPDATE ====================
        function updateEngine() {
            if (engine.damageStage >= 5) {
                engine.isRunning = false;
                engine.rpm = 0;
                engine.lubrication = 0;
                engine.heat = 0;
            }
            
            const isSeized = engine.damageStage >= 5;
            engine.rpmReductionPercent = isSeized ? 100 : Math.round((engine.damageStage * 400) / 3000 * 100);
            
            if (engine.isRunning) {
                const rpmFactor = engine.rpm / 3000;
                engine.crankAngle = (engine.crankAngle + 12 * rpmFactor) % 720;
                cylinders.forEach(cyl => cyl.update(engine.crankAngle, engine.rpmReductionPercent));
            }
            
            if (engine.statsFrozen || engine.damageStage >= 5) { updateUI(); return; }
            
            const effects = damageEffects[engine.damageStage];
            const oilLevel = engine.oilLevel;
            const rpmPercent = engine.rpm / 3000;
            
            // Lubrication logic - based on whether pump can get oil
            if (oilLevel >= 10) {
                const recovery = (100 - engine.lubrication) * 0.03;
                engine.lubrication = Math.min(100, engine.lubrication + recovery);
            } else {
                // Pump sucking air - rapid lubrication loss
                const oilFactor = (10 - oilLevel) / 10;
                const decayPerSecond = 20 + oilFactor * 13.3;
                const decayPerFrame = (decayPerSecond / 60) * effects.lubeLossMult;
                engine.lubrication = Math.max(0, engine.lubrication - decayPerFrame);
            }
            
            const lubLevel = engine.lubrication;
            let heatChange = 0;
            if (lubLevel < 50) {
                const lubFactor = (50 - lubLevel) / 50;
                const heatPerSecond = 1 + lubFactor * 32;
                const rpmBonus = 1 + (rpmPercent * engine.damageStage * 0.1);
                heatChange = (heatPerSecond / 60) * effects.heatMult * rpmBonus;
            } else {
                let coolingRate = oilLevel >= 50 ? 0.04 : oilLevel >= 10 ? 0.025 : 0.01;
                heatChange = -engine.heat * coolingRate;
            }
            engine.heat = Math.max(0, Math.min(100, engine.heat + heatChange));
            
            if (engine.isRunning) {
                const targetRPM = 3000 - (engine.damageStage * 400) - (engine.heat > 80 ? 500 : 0);
                engine.rpm = Math.max(0, engine.rpm + (targetRPM - engine.rpm) * 0.05);
            }
            
            const shouldTrigger = engine.heat > 90 && engine.damageStage < 5 && !engine.countdownActive && !engine.damagePopupVisible && !engine.infoPopupVisible && !engine.graceActive;
            if (shouldTrigger) { if (idleHintActive) hideIdleHint(); startCountdown(); }
            if (engine.countdownActive && engine.heat < 80) cancelCountdown(true);
            
            updateUI();
        }
        
        function updateProblemsUI() {
            const problems = stageProblems[engine.damageStage];
            if (problems.length === 0) { hudProblems.classList.remove('visible'); return; }
            hudProblems.classList.add('visible');
            problemsList.innerHTML = '';
            problems.forEach(problem => {
                const li = document.createElement('li');
                li.innerHTML = `<span class="problem-x">‚úï</span> ${problem}`;
                problemsList.appendChild(li);
            });
        }
        
        function updateConditionUI() {
            conditionText.textContent = stageConditions[engine.damageStage];
            hudCondition.classList.toggle('critical', engine.damageStage >= 3);
        }
        
        function updateUI() {
            const isSeized = engine.damageStage >= 5;
            const isOilCritical = engine.oilLevel < 10;
            const isLubLow = engine.lubrication < 30;
            const isHeatHigh = engine.heat > 60;
            const isWarpHigh = engine.warping > 30;
            const isCritical = engine.damageStage >= 3;
            
            checkOilLight.classList.toggle('active', engine.oilLevel < 25);
            checkEngineLight.classList.toggle('active', engine.heat > 70 || engine.lubrication < 40 || engine.damageStage >= 2);
            
            oilSliderFill.style.width = engine.oilLevel + '%';
            oilSliderBall.style.left = engine.oilLevel + '%';
            oilPercent.textContent = Math.round(engine.oilLevel);
            oilSliderFill.classList.toggle('low', isOilCritical);
            oilSliderBall.classList.toggle('low', isOilCritical);
            oilPercentage.classList.toggle('low', isOilCritical);
            oilSection.classList.toggle('warning', isOilCritical);
            oilWarningIcon.style.display = isOilCritical ? 'inline' : 'none';
            refillOilOverlay.classList.toggle('active', engine.countdownActive);
            
            const displayLube = isSeized ? 0 : engine.lubrication;
            const displayHeat = isSeized ? 0 : engine.heat;
            
            lubMeter.style.width = displayLube + '%';
            lubValue.textContent = Math.round(displayLube) + '%';
            lubMeter.classList.toggle('critical', isLubLow && !isSeized);
            lubValue.classList.toggle('critical', isLubLow && !isSeized);
            lubMeterContainer.classList.toggle('critical', isLubLow && !isSeized);
            
            heatMeter.style.width = displayHeat + '%';
            heatValue.textContent = Math.round(displayHeat) + '%';
            heatMeter.classList.toggle('critical', isHeatHigh && !isSeized);
            heatValue.classList.toggle('critical', isHeatHigh && !isSeized);
            heatMeterContainer.classList.toggle('critical', isHeatHigh && !isSeized);
            
            warpMeter.style.width = engine.warping + '%';
            warpValue.textContent = Math.round(engine.warping) + '%';
            warpMeter.classList.toggle('critical', isWarpHigh);
            warpValue.classList.toggle('critical', isWarpHigh);
            warpMeterContainer.classList.toggle('critical', isWarpHigh);
            
            const stage = damageStages[engine.damageStage];
            damageStageEl.textContent = stage.name;
            damageStageEl.className = 'hud-status-stage ' + stage.color;
            statusText.textContent = stage.description;
            hudStatus.classList.toggle('critical', engine.damageStage > 0);
            
            updateProblemsUI();
            updateConditionUI();
            engineWrapper.classList.toggle('warning', engine.countdownActive || isCritical);
            
            const isRpmLow = engine.rpm < 2000;
            engineRPM.textContent = Math.round(engine.rpm);
            engineRPM.classList.toggle('critical', isRpmLow);
            if (engine.rpmReductionPercent > 0) { rpmReduction.textContent = `-${engine.rpmReductionPercent}%`; rpmReduction.classList.add('visible'); }
            else { rpmReduction.classList.remove('visible'); }
        }
        
        // ==================== COUNTDOWN SYSTEM ====================
        function startCountdown() {
            engine.countdownActive = true;
            engine.countdownValue = 3;
            if (idleHintActive) hideIdleHint();
            showCountdownNumber(3);
            engine.countdownTimer = setInterval(() => {
                engine.countdownValue--;
                if (engine.countdownValue > 0) showCountdownNumber(engine.countdownValue);
                else { clearInterval(engine.countdownTimer); engine.countdownActive = false; refillOilOverlay.classList.remove('active'); triggerDamage(); }
            }, 1000);
        }
        
        function cancelCountdown(showSuccess = false) {
            if (engine.countdownTimer) clearInterval(engine.countdownTimer);
            engine.countdownActive = false;
            countdownNumber.classList.remove('visible');
            refillOilOverlay.classList.remove('active');
            if (showSuccess) {
                successCheckmark.classList.remove('visible'); void successCheckmark.offsetWidth; successCheckmark.classList.add('visible');
                successFlash.classList.remove('active'); void successFlash.offsetWidth; successFlash.classList.add('active');
            }
        }
        
        function showCountdownNumber(num) {
            countdownNumber.textContent = num;
            countdownNumber.classList.remove('visible'); void countdownNumber.offsetWidth; countdownNumber.classList.add('visible');
            warningFlash.classList.remove('active'); void warningFlash.offsetWidth; warningFlash.classList.add('active');
        }
        
        function triggerDamage() {
            if (engine.damageStage >= 5) return;
            engine.damageStage++;
            if (engine.warpAppliedAtStage < engine.damageStage) {
                engine.warping = Math.min(100, engine.warping + warpIncrements[engine.damageStage]);
                engine.warpAppliedAtStage = engine.damageStage;
            }
            engine.statsFrozen = true;
            if (idleHintActive) hideIdleHint();
            showDamagePopup();
        }
        
        // ==================== RENDER ====================
        function render() {
            const rect = engineWrapper.getBoundingClientRect();
            const displayWidth = rect.width;
            const displayHeight = rect.height;
            
            ctx.clearRect(0, 0, displayWidth, displayHeight);
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, displayWidth, displayHeight);
            
            ctx.save();
            const scaleX = displayWidth / CANVAS_WIDTH;
            const scaleY = displayHeight / CANVAS_HEIGHT;
            const baseScale = Math.min(scaleX, scaleY) * zoom.baseScale;
            const currentScale = (zoom.level / zoom.baseScale) * baseScale;
            const displayCenterX = displayWidth / 2;
            const displayCenterY = displayHeight / 2;
            ctx.translate(displayCenterX, displayCenterY);
            ctx.scale(currentScale, currentScale);
            ctx.translate(-ENGINE_CENTER_X + zoom.offsetX, -ENGINE_CENTER_Y + zoom.offsetY);
            
            drawEngineBlock(ctx);
            drawOilGalleries(ctx);
            drawOilPan(ctx);
            drawOilPumpAndPickup(ctx);
            drawCrankshaft(ctx, engine.crankAngle);
            cylinders.forEach(cyl => cyl.draw(ctx, engine));
            drawParticles(ctx);
            
            ctx.restore();
        }
        
        // ==================== MAIN LOOP ====================
        function gameLoop() {
            updateZoom();
            updateEngine();
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // ==================== OIL SLIDER INTERACTION ====================
        let isDragging = false;
        function updateOilFromPosition(clientX) {
            const rect = oilSliderTrack.getBoundingClientRect();
            const x = clientX - rect.left;
            engine.oilLevel = Math.max(0, Math.min(100, (x / rect.width) * 100));
            resetIdleTimer();
        }
        
        oilSliderTrack.addEventListener('mousedown', (e) => { isDragging = true; updateOilFromPosition(e.clientX); });
        oilSliderBall.addEventListener('mousedown', (e) => { isDragging = true; e.preventDefault(); });
        document.addEventListener('mousemove', (e) => { if (isDragging) updateOilFromPosition(e.clientX); });
        document.addEventListener('mouseup', () => { isDragging = false; });
        oilSliderTrack.addEventListener('touchstart', (e) => { isDragging = true; updateOilFromPosition(e.touches[0].clientX); });
        oilSliderBall.addEventListener('touchstart', (e) => { isDragging = true; e.preventDefault(); });
        document.addEventListener('touchmove', (e) => { if (isDragging) updateOilFromPosition(e.touches[0].clientX); });
        document.addEventListener('touchend', () => { isDragging = false; });
        
        refillBtn.addEventListener('click', () => { engine.oilLevel = 100; resetIdleTimer(); });
        resetBtn.addEventListener('click', () => {
            engine.oilLevel = 100; engine.lubrication = 100; engine.heat = 0; engine.warping = 0;
            engine.damageStage = 0; engine.warpAppliedAtStage = -1; engine.rpm = 3000;
            engine.rpmReductionPercent = 0; engine.isRunning = true; engine.statsFrozen = false;
            engine.damagePopupVisible = false; engine.infoPopupVisible = false; engine.graceActive = false;
            engine.frictionParticles = []; engine.windageParticles = []; engine.drainbackParticles = [];
            oilSystem.airBubbles = [];
            cylinders.forEach(cyl => { cyl.angle = cyl.baseAngle; cyl.pistonWarpAngle = 0; });
            cancelCountdown(false);
            infoOverlay.classList.remove('visible');
            refillOilOverlay.classList.remove('active');
            resetIdleTimer();
        });
        
        gameLoop();
    </script>
</body>
</html>
