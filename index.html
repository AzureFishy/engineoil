<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>V6 Engine Lubrication Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            color: #000;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        header {
            text-align: center;
            padding: 8px 0;
            border-bottom: 2px solid #000;
        }

        h1 {
            font-size: clamp(16px, 4vw, 24px);
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .subtitle {
            color: #666;
            font-size: clamp(10px, 2.5vw, 13px);
            margin-top: 3px;
        }

        .engine-canvas-wrapper {
            position: relative;
            background: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            overflow: hidden;
            flex-grow: 1;
            touch-action: none;
            min-height: 340px;
        }

        .engine-canvas-wrapper.warning {
            border-color: #cc0000;
            box-shadow: 0 0 20px rgba(204, 0, 0, 0.3);
        }

        #engineCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background: #fff;
            cursor: zoom-in;
        }

        #engineCanvas.zoomed {
            cursor: zoom-out;
        }

        /* ==================== WARNING LIGHTS - Updated colors ==================== */
        .warning-lights-top {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .warning-light {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #999;
            opacity: 0.05;
            transition: all 0.3s ease;
        }

        .warning-light .indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ddd;
            border: 1px solid #bbb;
            transition: all 0.3s ease;
        }

        /* Amber warnings (Check Oil, Check Engine) */
        .warning-light.amber.active {
            color: #cc8800;
            opacity: 1;
        }

        .warning-light.amber.active .indicator {
            background: #ffaa00;
            border-color: #cc8800;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.8);
            animation: lightPulseAmber 0.8s infinite;
        }

        .warning-light.amber.intermittent .indicator {
            animation: intermittentFlash 0.3s infinite;
        }

        @keyframes lightPulseAmber {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        @keyframes intermittentFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.2; }
        }

        /* Red warnings (Oil Pressure) */
        .warning-light.red.active {
            color: #cc0000;
            opacity: 1;
        }

        .warning-light.red.active .indicator {
            background: #cc0000;
            border-color: #aa0000;
            box-shadow: 0 0 10px rgba(204, 0, 0, 0.8);
            animation: lightPulseRed 0.8s infinite;
        }

        @keyframes lightPulseRed {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .hud-left-panel {
            position: absolute;
            top: 8px;
            left: 8px;
            width: clamp(100px, 18vw, 160px);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .hud-status {
            background: #fff;
            border: 1px solid #000;
            border-radius: 4px;
            padding: 6px 8px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .hud-status:hover { background: #f8f8f8; }
        .hud-status.critical { border-color: #cc0000; background: #fff5f5; }

        .hud-status-label {
            font-size: 7px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666;
            margin-bottom: 2px;
        }

        .hud-status-stage {
            font-size: 11px;
            font-weight: 700;
            color: #000;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            transition: color 0.3s ease;
        }

        .hud-status-stage.stage-1 { color: #996600; }
        .hud-status-stage.stage-2 { color: #cc4400; }
        .hud-status-stage.stage-3 { color: #cc0000; }
        .hud-status-stage.stage-4 { color: #aa0000; font-weight: 800; }
        .hud-status-stage.stage-5 { color: #880000; animation: criticalPulse 0.5s infinite; }

        @keyframes criticalPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .hud-status-text {
            font-size: 8px;
            color: #666;
            margin-top: 2px;
        }

        .hud-problems {
            background: #fff;
            border: 1px solid #cc0000;
            border-radius: 4px;
            padding: 6px 8px;
            display: none;
            cursor: pointer;
        }

        .hud-problems:hover { background: #fff8f8; }
        .hud-problems.visible { display: block; }

        .hud-problems-list { list-style: none; }

        .hud-problems-list li {
            font-size: 8px;
            color: #cc0000;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .hud-problems-list li:last-child { margin-bottom: 0; }
        .problem-x { font-weight: 700; font-size: 9px; }

        .hud-condition {
            background: #fff;
            border: 1px solid #000;
            border-radius: 4px;
            padding: 6px 8px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .hud-condition:hover { background: #f8f8f8; }
        .hud-condition.critical { border-color: #cc0000; background: #fff5f5; }

        .hud-condition-text {
            font-size: 8px;
            color: #333;
            line-height: 1.3;
            text-align: left;
        }

        .hud-condition.critical .hud-condition-text { color: #cc0000; }

        .hud-right-panel {
            position: absolute;
            top: 8px;
            right: 8px;
            bottom: 8px;
            width: clamp(90px, 16vw, 140px);
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 10;
        }

        .hud-rpm {
            background: #fff;
            border: 1px solid #000;
            border-radius: 4px;
            padding: 5px 8px;
            text-align: center;
            cursor: pointer;
        }

        .hud-rpm:hover { background: #f8f8f8; }

        .hud-rpm-label {
            font-size: 7px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
        }

        .hud-rpm-value-container {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 6px;
        }

        .hud-rpm-value {
            font-size: clamp(14px, 3vw, 20px);
            font-weight: 700;
            color: #000;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            line-height: 1.2;
            transition: color 0.3s ease;
        }

        .hud-rpm-value.critical { color: #cc0000; }

        .hud-rpm-reduction {
            font-size: clamp(8px, 1.5vw, 10px);
            font-weight: 600;
            color: #cc0000;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            line-height: 1;
            margin-top: 3px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .hud-rpm-reduction.visible { opacity: 1; }

        .hud-meters {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex-grow: 1;
        }

        .hud-meter {
            display: flex;
            align-items: stretch;
            gap: 0;
            cursor: pointer;
        }

        .hud-meter:hover .hud-meter-content { background: #f8f8f8; }
        .hud-meter.critical:hover .hud-meter-content { background: #fff0f0; }

        .hud-meter-warning {
            width: 16px;
            background: #cc0000;
            border-radius: 4px 0 0 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .hud-meter.critical .hud-meter-warning {
            opacity: 1;
            animation: warningFlash 1s infinite;
        }

        @keyframes warningFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .hud-meter-warning-icon { color: #fff; font-size: 10px; font-weight: bold; }

        .hud-meter-content {
            flex: 1;
            background: #fff;
            border: 1px solid #000;
            border-radius: 4px;
            padding: 5px 8px;
            transition: border-color 0.3s ease, background 0.3s ease;
        }

        .hud-meter.critical .hud-meter-content {
            border-color: #cc0000;
            border-left: none;
            border-radius: 0 4px 4px 0;
        }

        .hud-meter.critical .hud-meter-warning {
            border: 1px solid #cc0000;
            border-right: none;
        }

        .hud-meter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3px;
        }

        .hud-meter-label {
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666;
            font-weight: 600;
        }

        .hud-meter-value {
            font-size: 10px;
            font-weight: 700;
            color: #000;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            transition: color 0.3s ease;
        }

        .hud-meter-value.critical { color: #cc0000; }

        .hud-meter-bar-container {
            height: 6px;
            background: #eee;
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid #ddd;
        }

        .hud-meter-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .hud-meter-bar.lubrication { background: #000; }
        .hud-meter-bar.lubrication.critical { background: #cc0000; }
        .hud-meter-bar.heat { background: #000; }
        .hud-meter-bar.heat.critical { background: #cc0000; }
        .hud-meter-bar.warping { background: #000; }
        .hud-meter-bar.warping.critical { background: #cc0000; }

        /* ==================== STAGE PROGRESS BAR ==================== */
        .stage-progress-container {
            background: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stage-progress-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666;
            text-align: center;
            font-weight: 600;
        }

        .stage-progress-bar {
            display: flex;
            position: relative;
            height: 32px;
        }

        .stage-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            position: relative;
            padding-bottom: 2px;
        }

        .stage-indicator {
            position: absolute;
            top: 2px;
            font-size: 10px;
            font-weight: 700;
            color: #cc0000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .stage-item.damaged .stage-indicator {
            opacity: 1;
        }

        .stage-name {
            font-size: clamp(7px, 1.8vw, 9px);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            color: #999;
            transition: color 0.3s ease;
        }

        .stage-item.current .stage-name {
            color: #666;
        }

        .stage-item.damaged .stage-name {
            color: #cc0000;
        }

        /* Nominal stage stays gray always */
        .stage-item[data-stage="0"] .stage-name {
            color: #999;
        }

        .stage-item[data-stage="0"].current .stage-name {
            color: #666;
        }

        .stage-arrow {
            position: absolute;
            top: -12px;
            font-size: 16px;
            font-weight: 900;
            color: #000;
            z-index: 100;
            /* White outline */
            text-shadow: 
                -1px -1px 0 #fff,
                1px -1px 0 #fff,
                -1px 1px 0 #fff,
                1px 1px 0 #fff,
                -1px 0 0 #fff,
                1px 0 0 #fff,
                0 -1px 0 #fff,
                0 1px 0 #fff;
            animation: arrowBob 1s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes arrowBob {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-4px); }
        }

        .stage-divider {
            width: 1px;
            background: #ddd;
            height: 100%;
            position: absolute;
            right: 0;
            top: 0;
        }

        .stage-item:last-child .stage-divider {
            display: none;
        }

        /* ==================== OVERLAY SYSTEM ==================== */
        .overlay-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 20;
        }

        .countdown-number {
            font-size: clamp(120px, 35vw, 250px);
            font-weight: 900;
            color: #cc0000;
            opacity: 0;
            transform: scale(2);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            position: absolute;
            text-shadow: 
                -3px -3px 0 #fff, 3px -3px 0 #fff, -3px 3px 0 #fff, 3px 3px 0 #fff,
                -3px 0 0 #fff, 3px 0 0 #fff, 0 -3px 0 #fff, 0 3px 0 #fff,
                0 0 40px rgba(204, 0, 0, 0.6), 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .countdown-number.visible {
            animation: countdownPulse 1s ease-out forwards;
        }

        @keyframes countdownPulse {
            0% { transform: scale(2); opacity: 0; }
            15% { transform: scale(1); opacity: 1; }
            85% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0; }
        }

        .success-checkmark {
            font-size: clamp(100px, 30vw, 200px);
            color: #00aa44;
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
            position: absolute;
            text-shadow: 
                -3px -3px 0 #fff, 3px -3px 0 #fff, -3px 3px 0 #fff, 3px 3px 0 #fff,
                -3px 0 0 #fff, 3px 0 0 #fff, 0 -3px 0 #fff, 0 3px 0 #fff,
                0 0 40px rgba(0, 170, 68, 0.6), 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .success-checkmark.visible {
            animation: checkmarkPop 1.2s ease-out forwards;
        }

        @keyframes checkmarkPop {
            0% { transform: scale(0.5); opacity: 0; }
            20% { transform: scale(1.2); opacity: 1; }
            40% { transform: scale(1); opacity: 1; }
            80% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0; }
        }

        .warning-flash-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(204, 0, 0, 0.12);
            pointer-events: none;
            opacity: 0;
            z-index: 15;
        }

        .warning-flash-overlay.active {
            animation: flashWarningOverlay 0.3s ease-out;
        }

        @keyframes flashWarningOverlay {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .success-flash-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 170, 68, 0.15);
            pointer-events: none;
            opacity: 0;
            z-index: 15;
        }

        .success-flash-overlay.active {
            animation: flashSuccess 0.4s ease-out;
        }

        @keyframes flashSuccess {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .info-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.75);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 25;
        }

        .info-overlay.visible {
            opacity: 1;
            pointer-events: auto;
            cursor: pointer;
        }

        .info-overlay-content {
            background: #fff;
            padding: clamp(16px, 4vw, 40px) clamp(20px, 5vw, 50px);
            border: 3px solid #000;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            width: clamp(240px, 70%, 450px);
        }

        .info-overlay.damage-mode .info-overlay-content { border-color: #cc0000; }

        .info-overlay-title {
            font-size: clamp(16px, 4vw, 28px);
            margin-bottom: 8px;
            color: #000;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-overlay.damage-mode .info-overlay-title { color: #cc0000; }

        .info-overlay-stage {
            font-size: clamp(12px, 3vw, 20px);
            font-weight: 700;
            color: #000;
            margin-bottom: 12px;
        }

        .info-overlay.damage-mode .info-overlay-stage { color: #cc0000; }

        .info-overlay-description {
            font-size: clamp(10px, 2.5vw, 14px);
            color: #333;
            line-height: 1.5;
            margin-bottom: 16px;
            text-align: left;
        }

        .info-overlay-tap {
            font-size: clamp(9px, 2vw, 12px);
            color: #888;
            font-style: italic;
        }

        /* ==================== TUTORIAL SYSTEM ==================== */
        .tutorial-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 100;
            display: none;
            cursor: pointer;
        }

        .tutorial-overlay.active { display: block; }

        .tutorial-spotlight {
            position: absolute;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            pointer-events: none;
            transition: all 0.4s ease;
        }

        .tutorial-arrow-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.4s ease;
        }

        .tutorial-arrow-container.position-below { flex-direction: column; }
        .tutorial-arrow-container.position-above { flex-direction: column-reverse; }
        .tutorial-arrow-container.position-left { flex-direction: row-reverse; }
        .tutorial-arrow-container.position-right { flex-direction: row; }

        .tutorial-arrow {
            font-size: 60px;
            font-weight: 900;
            color: #000;
            line-height: 1;
            text-shadow: 
                -2px -2px 0 #fff, 2px -2px 0 #fff, -2px 2px 0 #fff, 2px 2px 0 #fff,
                -2px 0 0 #fff, 2px 0 0 #fff, 0 -2px 0 #fff, 0 2px 0 #fff,
                0 0 10px rgba(255, 255, 255, 0.8);
        }

        .tutorial-arrow-container.position-below .tutorial-arrow { animation: arrowBounceDown 1s ease-in-out infinite; }
        .tutorial-arrow-container.position-above .tutorial-arrow { animation: arrowBounceUp 1s ease-in-out infinite; }
        .tutorial-arrow-container.position-left .tutorial-arrow { animation: arrowBounceLeft 1s ease-in-out infinite; }
        .tutorial-arrow-container.position-right .tutorial-arrow { animation: arrowBounceRight 1s ease-in-out infinite; }

        @keyframes arrowBounceDown { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(15px); } }
        @keyframes arrowBounceUp { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        @keyframes arrowBounceLeft { 0%, 100% { transform: translateX(0); } 50% { transform: translateX(-15px); } }
        @keyframes arrowBounceRight { 0%, 100% { transform: translateX(0); } 50% { transform: translateX(15px); } }

        .tutorial-text {
            background: #fff;
            padding: 12px 18px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #333;
            max-width: 250px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 2px solid #000;
        }

        .tutorial-text small {
            display: block;
            margin-top: 6px;
            font-size: 11px;
            color: #888;
        }

        .tutorial-progress {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 101;
        }

        .tutorial-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #000;
            transition: all 0.3s ease;
        }

        .tutorial-dot.active { background: #000; transform: scale(1.2); }
        .tutorial-dot.completed { background: #00aa44; border-color: #00aa44; }
        .tutorial-overlay.idle-hint .tutorial-progress { display: none; }

        /* Row 3: Oil Slider + Buttons */
        .oil-slider-row {
            display: flex;
            gap: 10px;
            align-items: stretch;
        }

        .oil-slider-container {
            flex: 1;
            background: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            padding: 10px 16px; /* Increased left/right padding */
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .oil-slider-container.warning {
            border-color: #cc0000;
            box-shadow: 0 0 15px rgba(204, 0, 0, 0.2);
        }

        .refill-oil-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(204, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            border-radius: 6px;
        }

        .refill-oil-overlay.active {
            animation: refillFlash 0.5s ease-in-out infinite;
        }

        @keyframes refillFlash {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 0.5; }
        }

        .refill-oil-text {
            color: #fff;
            font-size: clamp(16px, 4vw, 24px);
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .oil-slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .oil-slider-title {
            font-size: clamp(10px, 2.5vw, 12px);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .warning-icon {
            color: #cc0000;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .oil-percentage {
            font-size: clamp(18px, 5vw, 28px);
            font-weight: 700;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            transition: color 0.3s ease;
        }

        .oil-percentage.low { color: #cc0000; }

        .oil-slider-track-wrapper { position: relative; }

        .oil-slider-track {
            height: clamp(14px, 3vw, 20px);
            background: #e8e8e8;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            border: 1px solid #ccc;
        }

        .critical-line {
            position: absolute;
            left: 10%;
            top: -4px;
            bottom: -4px;
            width: 0;
            border-left: 2px dashed #cc0000;
            pointer-events: none;
            z-index: 2;
        }

        .check-oil-line {
            position: absolute;
            left: 25%;
            top: -4px;
            bottom: -4px;
            width: 0;
            border-left: 2px dashed #dd8800;
            pointer-events: none;
            z-index: 2;
        }

        .oil-slider-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #333, #000);
            border-radius: 9px;
            transition: width 0.1s ease;
        }

        .oil-slider-fill.low {
            background: linear-gradient(90deg, #cc0000, #ff4444);
        }

        .oil-slider-ball {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: clamp(24px, 6vw, 34px);
            height: clamp(24px, 6vw, 34px);
            background: #fff;
            border: 3px solid #000;
            border-radius: 50%;
            cursor: grab;
            transition: box-shadow 0.2s ease, border-color 0.3s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            z-index: 3;
        }

        .oil-slider-ball:hover { box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); }
        .oil-slider-ball:active { cursor: grabbing; }
        .oil-slider-ball.low { border-color: #cc0000; }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: clamp(8px, 2vw, 10px);
            color: #999;
            margin-top: 6px;
        }

        .buttons-container {
            display: flex;
            gap: 6px;
        }

        .refill-btn, .reset-btn {
            width: clamp(50px, 10vw, 80px);
            height: 100%;
            background: #000;
            color: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            font-size: clamp(8px, 2vw, 10px);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .refill-btn:hover, .reset-btn:hover { background: #333; border-color: #333; }
        .refill-btn:active, .reset-btn:active { background: #555; }
        .refill-btn .btn-icon, .reset-btn .btn-icon { font-size: clamp(16px, 4vw, 22px); }

        /* ==================== DESKTOP / LANDSCAPE ==================== */
        @media (min-width: 601px), (orientation: landscape) {
            .container { padding-left: 5%; padding-right: 5%; }
            .engine-canvas-wrapper { min-height: 390px; }
        }

        /* ==================== MOBILE PORTRAIT ==================== */
        @media (max-width: 600px) and (orientation: portrait) {
            .engine-canvas-wrapper { min-height: 36vh; }
            .hud-left-panel { left: 4px; width: clamp(80px, 22vw, 110px); }
            .hud-right-panel { right: 4px; width: clamp(70px, 20vw, 100px); }
            .tutorial-text { max-width: 250px; }
            .warning-lights-top { gap: 8px; }
            .warning-light { font-size: 8px; gap: 3px; }
            .warning-light .indicator { width: 8px; height: 8px; }
        }

        /* ==================== RESPONSIVE ==================== */
        @media (max-width: 500px) {
            .warning-lights-top { gap: 6px; }
            .warning-light { font-size: 7px; }
            .warning-light .indicator { width: 7px; height: 7px; }
            .hud-status { padding: 4px 6px; }
            .hud-status-stage { font-size: 9px; }
            .hud-problems { padding: 4px 6px; }
            .hud-problems-list li { font-size: 7px; }
            .hud-condition { padding: 4px 6px; }
            .hud-condition-text { font-size: 7px; }
            .hud-rpm { padding: 4px 6px; }
            .hud-rpm-value { font-size: 14px; }
            .hud-rpm-reduction { font-size: 7px; }
            .hud-meter-content { padding: 4px 6px; }
            .hud-meter-label { font-size: 6px; }
            .hud-meter-value { font-size: 8px; }
            .hud-meter-bar-container { height: 4px; }
            .hud-meter-warning { width: 12px; }
            .hud-meter-warning-icon { font-size: 8px; }
            .tutorial-text { font-size: 12px; padding: 10px 14px; }
            .tutorial-arrow { font-size: 45px; }
            .info-overlay-content { padding: 12px 16px; }
            .info-overlay-title { font-size: 14px; }
            .info-overlay-stage { font-size: 11px; }
            .info-overlay-description { font-size: 10px; }
            .buttons-container { gap: 4px; }
            .refill-btn, .reset-btn { width: clamp(45px, 12vw, 70px); }
            .stage-progress-container { padding: 6px 8px; }
            .stage-name { font-size: 7px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>V6 Engine Lubrication Simulation</h1>
            <p class="subtitle">Interactive demonstration of engine operation and oil system failure</p>
        </header>
        
        <div class="engine-canvas-wrapper" id="engineWrapper">
            <canvas id="engineCanvas"></canvas>
            
            <!-- Updated Warning Lights with 3 indicators -->
            <div class="warning-lights-top">
                <div class="warning-light amber" id="checkOilLight">
                    <span class="indicator"></span>
                    <span>Check Oil</span>
                </div>
                <div class="warning-light red" id="oilPressureLight">
                    <span class="indicator"></span>
                    <span>Oil Pressure</span>
                </div>
                <div class="warning-light amber" id="checkEngineLight">
                    <span class="indicator"></span>
                    <span>Check Engine</span>
                </div>
            </div>
            
            <div class="hud-left-panel" id="hudLeftPanel">
                <div class="hud-status" id="hudStatus" data-info="status">
                    <div class="hud-status-label">Eng. Status</div>
                    <div class="hud-status-stage" id="damageStage">PERFECT</div>
                    <div class="hud-status-text" id="statusText">1: Nominal</div>
                </div>
                <div class="hud-problems" id="hudProblems" data-info="problems">
                    <ul class="hud-problems-list" id="problemsList"></ul>
                </div>
                <div class="hud-condition" id="hudCondition" data-info="condition">
                    <div class="hud-condition-text" id="conditionText">Engine running at peak performance.</div>
                </div>
            </div>
            
            <div class="hud-right-panel" id="hudRightPanel">
                <div class="hud-rpm" id="hudRpm" data-info="rpm">
                    <div class="hud-rpm-label">RPM</div>
                    <div class="hud-rpm-value-container">
                        <div class="hud-rpm-value" id="engineRPM">3000</div>
                        <div class="hud-rpm-reduction" id="rpmReduction">-0%</div>
                    </div>
                </div>
                <div class="hud-meters">
                    <div class="hud-meter" id="lubMeterContainer" data-info="lube">
                        <div class="hud-meter-warning"><span class="hud-meter-warning-icon">‚ö†</span></div>
                        <div class="hud-meter-content">
                            <div class="hud-meter-header">
                                <span class="hud-meter-label">Lube</span>
                                <span class="hud-meter-value" id="lubValue">100%</span>
                            </div>
                            <div class="hud-meter-bar-container">
                                <div class="hud-meter-bar lubrication" id="lubMeter" style="width: 100%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="hud-meter" id="heatMeterContainer" data-info="heat">
                        <div class="hud-meter-warning"><span class="hud-meter-warning-icon">‚ö†</span></div>
                        <div class="hud-meter-content">
                            <div class="hud-meter-header">
                                <span class="hud-meter-label">Heat</span>
                                <span class="hud-meter-value" id="heatValue">0%</span>
                            </div>
                            <div class="hud-meter-bar-container">
                                <div class="hud-meter-bar heat" id="heatMeter" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="hud-meter" id="warpMeterContainer" data-info="warp">
                        <div class="hud-meter-warning"><span class="hud-meter-warning-icon">‚ö†</span></div>
                        <div class="hud-meter-content">
                            <div class="hud-meter-header">
                                <span class="hud-meter-label">Mtl. Warp</span>
                                <span class="hud-meter-value" id="warpValue">0%</span>
                            </div>
                            <div class="hud-meter-bar-container">
                                <div class="hud-meter-bar warping" id="warpMeter" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="overlay-container">
                <div class="countdown-number" id="countdownNumber">3</div>
                <div class="success-checkmark" id="successCheckmark">‚úì</div>
            </div>
            <div class="warning-flash-overlay" id="warningFlash"></div>
            <div class="success-flash-overlay" id="successFlash"></div>
            <div class="info-overlay" id="infoOverlay">
                <div class="info-overlay-content">
                    <div class="info-overlay-title" id="infoOverlayTitle">‚ö† Engine Damage</div>
                    <div class="info-overlay-stage" id="infoOverlayStage">Stage 2: WEAR</div>
                    <div class="info-overlay-description" id="infoOverlayDescription"></div>
                    <div class="info-overlay-tap">Tap anywhere to continue</div>
                </div>
            </div>
        </div>
        
        <!-- Stage Progress Bar - No click handlers -->
        <div class="stage-progress-container" id="stageProgressContainer">
            <div class="stage-progress-label">Damage Progression</div>
            <div class="stage-progress-bar" id="stageProgressBar">
                <div class="stage-arrow" id="stageArrow">‚ñº</div>
                <div class="stage-item current" data-stage="0">
                    <span class="stage-indicator">‚úï</span>
                    <span class="stage-name">Nominal</span>
                    <div class="stage-divider"></div>
                </div>
                <div class="stage-item" data-stage="1">
                    <span class="stage-indicator">‚úï</span>
                    <span class="stage-name">Wear</span>
                    <div class="stage-divider"></div>
                </div>
                <div class="stage-item" data-stage="2">
                    <span class="stage-indicator">‚úï</span>
                    <span class="stage-name">Bearings</span>
                    <div class="stage-divider"></div>
                </div>
                <div class="stage-item" data-stage="3">
                    <span class="stage-indicator">‚úï</span>
                    <span class="stage-name">Scoring</span>
                    <div class="stage-divider"></div>
                </div>
                <div class="stage-item" data-stage="4">
                    <span class="stage-indicator">‚úï</span>
                    <span class="stage-name">Critical</span>
                    <div class="stage-divider"></div>
                </div>
                <div class="stage-item" data-stage="5">
                    <span class="stage-indicator">‚úï</span>
                    <span class="stage-name">Seized</span>
                </div>
            </div>
        </div>
        
        <div class="oil-slider-row" id="oilSliderRow">
            <div class="oil-slider-container" id="oilSection">
                <div class="refill-oil-overlay" id="refillOilOverlay">
                    <span class="refill-oil-text">‚ö† REFILL OIL ‚ö†</span>
                </div>
                <div class="oil-slider-header">
                    <div class="oil-slider-title">
                        Oil Level
                        <span class="warning-icon" id="oilWarningIcon" style="display: none;">‚ö†</span>
                    </div>
                    <div class="oil-percentage" id="oilPercentage"><span id="oilPercent">100</span>%</div>
                </div>
                <div class="oil-slider-track-wrapper">
                    <div class="critical-line"></div>
                    <div class="check-oil-line"></div>
                    <div class="oil-slider-track" id="oilSliderTrack">
                        <div class="oil-slider-fill" id="oilSliderFill"></div>
                        <div class="oil-slider-ball" id="oilSliderBall"></div>
                    </div>
                </div>
                <div class="slider-labels">
                    <span>Empty</span>
                    <span>Full</span>
                </div>
            </div>
            <div class="buttons-container" id="buttonsContainer">
                <button class="refill-btn" id="refillBtn">
                    <span class="btn-icon">üõ¢Ô∏è</span>
                    <span>Refill</span>
                </button>
                <button class="reset-btn" id="resetBtn">
                    <span class="btn-icon">‚öôÔ∏è</span>
                    <span>Reset</span>
                </button>
            </div>
        </div>
    </div>
    
    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-spotlight" id="tutorialSpotlight"></div>
        <div class="tutorial-arrow-container" id="tutorialArrowContainer">
            <div class="tutorial-arrow" id="tutorialArrow">‚ñº</div>
            <div class="tutorial-text" id="tutorialText">
                Tutorial text here
                <small>Tap to continue</small>
            </div>
        </div>
        <div class="tutorial-progress" id="tutorialProgress"></div>
    </div>

    <script>
        // ==================== CANVAS SETUP ====================
        const canvas = document.getElementById('engineCanvas');
        const ctx = canvas.getContext('2d');
        const engineWrapper = document.getElementById('engineWrapper');
        
        const CANVAS_WIDTH = 1040;
        const CANVAS_HEIGHT = 520;
        const ENGINE_CENTER_X = 520;
        const ENGINE_CENTER_Y = 280;
        
        function resizeCanvas() {
            const rect = engineWrapper.getBoundingClientRect();
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // ==================== ZOOM STATE ====================
        const zoom = {
            level: 1, targetLevel: 1,
            offsetX: 0, offsetY: 0,
            targetOffsetX: 0, targetOffsetY: 0,
            isZoomed: false,
            baseScale: 1.035, zoomedScale: 1.6
        };
        
        // ==================== ENGINE STATE ====================
        const engine = {
            oilLevel: 100, lubrication: 100, heat: 0, warping: 0,
            damageStage: 0, maxReachedStage: 0, rpm: 3000, crankAngle: 0,
            isRunning: true, countdownActive: false, countdownValue: 3,
            countdownTimer: null, damagePopupVisible: false, infoPopupVisible: false,
            graceActive: false, frictionParticles: [], windageParticles: [],
            drainbackParticles: [], warpAppliedAtStage: -1, statsFrozen: false,
            rpmReductionPercent: 0, galleryFlowOffset: 0, pumpSuckingAir: false,
            suckingAirFlashOn: false
        };
        
        // Sucking air flash timer
        setInterval(() => {
            engine.suckingAirFlashOn = !engine.suckingAirFlashOn;
        }, 400);
        
        const warpIncrements = [0, 5, 10, 18, 30, 50];
        const damageEffects = [
            { lubeLossMult: 1.0, heatMult: 1.0 },
            { lubeLossMult: 1.3, heatMult: 1.3 },
            { lubeLossMult: 1.6, heatMult: 1.6 },
            { lubeLossMult: 2.0, heatMult: 2.0 },
            { lubeLossMult: 2.5, heatMult: 2.5 },
            { lubeLossMult: 3.0, heatMult: 3.0 }
        ];
        
        const stageProblems = [
            [], ["-13% RPMs"], ["-27% RPMs", "more friction"],
            ["-40% RPMs", "high friction", "metal warped"],
            ["-53% RPMs", "major friction", "severe warping"],
            ["replace engine"]
        ];
        
        const stageConditions = [
            "Engine running at peak performance.",
            "Minor wear detected, efficiency slightly reduced.",
            "Bearing damage causing increased friction.",
            "Cylinder scoring with significant metal warping.",
            "Severe internal damage, failure imminent.",
            "Engine has seized. Replacement required."
        ];
        
        const damageDescriptions = [
            "",
            "<b>Surface wear</b> has formed on cylinder walls from excessive friction. You'll notice <b>reduced RPM capacity</b> and the engine will have a harder time maintaining lubrication.",
            "<b>Main bearings are damaged</b> from heat stress. Friction is now <b>significantly higher</b>, making it harder for oil to properly lubricate moving parts.",
            "<b>Deep scoring marks</b> have formed on cylinder walls from metal-to-metal contact. <b>Permanent metal warping</b> has begun.",
            "<b>Severe internal damage</b> throughout the engine. Connecting rods and crankshaft bearings are <b>compromised</b>.",
            "The engine has <b>completely seized</b>. Pistons have welded to cylinder walls. The engine <b>cannot be repaired</b>."
        ];
        
        const damageStages = [
            { name: "PERFECT", description: "1: Nominal", color: "" },
            { name: "WEAR", description: "2: Wear", color: "stage-1" },
            { name: "BEARING", description: "3: Damage", color: "stage-2" },
            { name: "SCORING", description: "4: Cylinder", color: "stage-3" },
            { name: "CRITICAL", description: "5: Severe", color: "stage-4" },
            { name: "SEIZED", description: "6: Failed", color: "stage-5" }
        ];
        
        const infoContent = {
            rpm: { title: "RPM Meter", description: "<b>RPM</b> shows crankshaft speed. Damage reduces max RPM." },
            lube: { title: "Lubrication", description: "<b>Lubrication</b> shows oil coating. Below <b>10% oil</b>, pump sucks air." },
            heat: { title: "Heat Meter", description: "<b>Heat</b> builds when lube drops below <b>50%</b>. At <b>90%</b>, countdown begins." },
            warp: { title: "Metal Warping", description: "<b>Warping</b> is permanent damage. Causes piston misalignment." },
            status: { title: "Engine Status", description: "Shows damage stage from <b>1 (Perfect)</b> to <b>6 (Seized)</b>." },
            problems: { title: "Problems", description: "Lists active issues: RPM loss, friction, warping." },
            condition: { title: "Condition", description: "Summary of engine health and operational status." }
        };
        
        // ==================== DOM ELEMENTS ====================
        const oilSliderTrack = document.getElementById('oilSliderTrack');
        const oilSliderFill = document.getElementById('oilSliderFill');
        const oilSliderBall = document.getElementById('oilSliderBall');
        const oilPercent = document.getElementById('oilPercent');
        const oilPercentage = document.getElementById('oilPercentage');
        const oilSection = document.getElementById('oilSection');
        const oilWarningIcon = document.getElementById('oilWarningIcon');
        const refillOilOverlay = document.getElementById('refillOilOverlay');
        const lubMeter = document.getElementById('lubMeter');
        const lubValue = document.getElementById('lubValue');
        const lubMeterContainer = document.getElementById('lubMeterContainer');
        const heatMeter = document.getElementById('heatMeter');
        const heatValue = document.getElementById('heatValue');
        const heatMeterContainer = document.getElementById('heatMeterContainer');
        const warpMeter = document.getElementById('warpMeter');
        const warpValue = document.getElementById('warpValue');
        const warpMeterContainer = document.getElementById('warpMeterContainer');
        const damageStageEl = document.getElementById('damageStage');
        const statusText = document.getElementById('statusText');
        const hudStatus = document.getElementById('hudStatus');
        const hudProblems = document.getElementById('hudProblems');
        const problemsList = document.getElementById('problemsList');
        const hudCondition = document.getElementById('hudCondition');
        const conditionText = document.getElementById('conditionText');
        const countdownNumber = document.getElementById('countdownNumber');
        const successCheckmark = document.getElementById('successCheckmark');
        const warningFlash = document.getElementById('warningFlash');
        const successFlash = document.getElementById('successFlash');
        const infoOverlay = document.getElementById('infoOverlay');
        const infoOverlayTitle = document.getElementById('infoOverlayTitle');
        const infoOverlayStage = document.getElementById('infoOverlayStage');
        const infoOverlayDescription = document.getElementById('infoOverlayDescription');
        const resetBtn = document.getElementById('resetBtn');
        const refillBtn = document.getElementById('refillBtn');
        const engineRPM = document.getElementById('engineRPM');
        const rpmReduction = document.getElementById('rpmReduction');
        const checkOilLight = document.getElementById('checkOilLight');
        const oilPressureLight = document.getElementById('oilPressureLight');
        const checkEngineLight = document.getElementById('checkEngineLight');
        const stageProgressBar = document.getElementById('stageProgressBar');
        const stageArrow = document.getElementById('stageArrow');
        const stageItems = document.querySelectorAll('.stage-item');
        
        // ==================== STAGE PROGRESS BAR ====================
        function updateStageProgressBar() {
            stageItems.forEach((item, i) => {
                item.classList.remove('current', 'damaged');
                
                // Current stage
                if (i === engine.damageStage) {
                    item.classList.add('current');
                    // Stages 1-5 (not Nominal) get damaged class when current
                    if (i > 0) {
                        item.classList.add('damaged');
                    }
                }
                // Completed/past stages (red X)
                else if (i < engine.damageStage && i > 0) {
                    item.classList.add('damaged');
                }
            });
            
            // Track max reached stage
            if (engine.damageStage > engine.maxReachedStage) {
                engine.maxReachedStage = engine.damageStage;
            }
            
            // Position arrow
            const currentItem = stageItems[engine.damageStage];
            if (currentItem) {
                const itemRect = currentItem.getBoundingClientRect();
                const barRect = stageProgressBar.getBoundingClientRect();
                const centerX = itemRect.left - barRect.left + itemRect.width / 2;
                stageArrow.style.left = centerX + 'px';
            }
        }
        
        // ==================== INFO POPUP SYSTEM ====================
        function showInfoPopup(infoKey) {
            if (engine.countdownActive || engine.damagePopupVisible) return;
            const info = infoContent[infoKey];
            if (!info) return;
            engine.infoPopupVisible = true;
            engine.statsFrozen = true;
            infoOverlay.classList.remove('damage-mode');
            infoOverlayTitle.textContent = info.title;
            infoOverlayStage.style.display = 'none';
            infoOverlayDescription.innerHTML = info.description;
            infoOverlay.classList.add('visible');
        }
        
        function showDamagePopup() {
            engine.damagePopupVisible = true;
            engine.statsFrozen = true;
            infoOverlay.classList.add('damage-mode');
            infoOverlayTitle.textContent = '‚ö† Engine Damage';
            infoOverlayStage.style.display = 'block';
            infoOverlayStage.textContent = `Stage ${engine.damageStage + 1}: ${damageStages[engine.damageStage].name}`;
            infoOverlayDescription.innerHTML = damageDescriptions[engine.damageStage];
            infoOverlay.classList.add('visible');
            refillOilOverlay.classList.remove('active');
            warningFlash.classList.remove('active');
            void warningFlash.offsetWidth;
            warningFlash.classList.add('active');
        }
        
        function hideInfoOverlay() {
            infoOverlay.classList.remove('visible');
            if (engine.damagePopupVisible) {
                engine.damagePopupVisible = false;
                engine.statsFrozen = false;
                engine.graceActive = true;
                setTimeout(() => {
                    engine.graceActive = false;
                    if (engine.heat > 90 && engine.damageStage < 5 && !engine.countdownActive) startCountdown();
                }, 2000);
            } else if (engine.infoPopupVisible) {
                engine.infoPopupVisible = false;
                engine.statsFrozen = false;
            }
        }
        
        infoOverlay.addEventListener('click', hideInfoOverlay);
        document.querySelectorAll('[data-info]').forEach(el => {
            el.addEventListener('click', (e) => { e.stopPropagation(); showInfoPopup(el.dataset.info); });
        });
        
        // ==================== ZOOM ====================
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
            else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
            else { clientX = e.clientX; clientY = e.clientY; }
            return { relX: (clientX - rect.left) / rect.width, relY: (clientY - rect.top) / rect.height };
        }
        
        function handleZoomTap(e) {
            if (engine.damagePopupVisible || engine.infoPopupVisible || tutorialActive || idleHintActive) return;
            e.preventDefault();
            const coords = getCanvasCoordinates(e);
            if (zoom.isZoomed) {
                zoom.isZoomed = false; zoom.targetLevel = zoom.baseScale;
                zoom.targetOffsetX = 0; zoom.targetOffsetY = 0;
                canvas.classList.remove('zoomed');
            } else {
                zoom.isZoomed = true; zoom.targetLevel = zoom.zoomedScale;
                canvas.classList.add('zoomed');
                const dx = (coords.relX - 0.5) * 2, dy = (coords.relY - 0.5) * 2;
                zoom.targetOffsetX = -dx * 150; zoom.targetOffsetY = -dy * 150;
            }
        }
        
        canvas.addEventListener('click', handleZoomTap);
        canvas.addEventListener('touchend', (e) => { if (e.cancelable) e.preventDefault(); handleZoomTap(e); }, { passive: false });
        
        function updateZoom() {
            const s = 0.12;
            zoom.level += (zoom.targetLevel - zoom.level) * s;
            zoom.offsetX += (zoom.targetOffsetX - zoom.offsetX) * s;
            zoom.offsetY += (zoom.targetOffsetY - zoom.offsetY) * s;
        }
        
        // ==================== TUTORIAL SYSTEM ====================
        const tutorialOverlay = document.getElementById('tutorialOverlay');
        const tutorialSpotlight = document.getElementById('tutorialSpotlight');
        const tutorialArrowContainer = document.getElementById('tutorialArrowContainer');
        const tutorialArrow = document.getElementById('tutorialArrow');
        const tutorialText = document.getElementById('tutorialText');
        const tutorialProgress = document.getElementById('tutorialProgress');
        
        const tutorialSteps = [
            { target: 'oilSection', position: 'above', text: '<b>Drag this slider</b> to control the <b>oil level</b>. Low oil causes engine damage!' },
            { target: 'hudRightPanel', position: 'left', text: 'Monitor <b>engine stats</b>: <b>RPM</b>, <b>lubrication</b>, <b>heat</b>, and <b>warping</b>.' },
            { target: 'stageProgressContainer', position: 'above', text: '<b>Your goal:</b> Experience all <b>6 damage stages</b> by letting the engine overheat!' },
            { target: 'buttonsContainer', position: 'above', text: 'Use <b>Refill</b> to add oil, or <b>Reset</b> to restore the engine.' }
        ];
        
        let currentTutorialStep = 0, tutorialAutoTimer = null, tutorialActive = false, tutorialCompleted = false;
        let idleTimer = null, idleHintActive = false;
        const IDLE_TIMEOUT = 15000;
        
        function resetIdleTimer() {
            if (idleTimer) clearTimeout(idleTimer);
            if (idleHintActive) hideIdleHint();
            if (tutorialCompleted && !tutorialActive && !engine.countdownActive && !engine.damagePopupVisible && !engine.infoPopupVisible)
                idleTimer = setTimeout(showIdleHint, IDLE_TIMEOUT);
        }
        
        function showIdleHint() {
            if (tutorialActive || engine.countdownActive || engine.damagePopupVisible || engine.infoPopupVisible) return;
            idleHintActive = true;
            tutorialOverlay.classList.add('active', 'idle-hint');
            const targetEl = document.getElementById('oilSection');
            const rect = targetEl.getBoundingClientRect();
            tutorialSpotlight.style.left = (rect.left - 8) + 'px';
            tutorialSpotlight.style.top = (rect.top - 8) + 'px';
            tutorialSpotlight.style.width = (rect.width + 16) + 'px';
            tutorialSpotlight.style.height = (rect.height + 16) + 'px';
            tutorialArrow.textContent = '‚ñº';
            tutorialArrowContainer.className = 'tutorial-arrow-container position-above';
            tutorialArrowContainer.style.left = (rect.left + rect.width / 2) + 'px';
            tutorialArrowContainer.style.top = (rect.top - 8) + 'px';
            tutorialArrowContainer.style.transform = 'translate(-50%, -100%)';
            tutorialText.innerHTML = '<b>Move oil level slider</b> to affect the engine<small>Tap to dismiss</small>';
        }
        
        function hideIdleHint() { idleHintActive = false; tutorialOverlay.classList.remove('active', 'idle-hint'); }
        function handleUserInteraction() { resetIdleTimer(); }
        ['mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend', 'keydown', 'keyup', 'scroll', 'wheel', 'click'].forEach(evt => document.addEventListener(evt, handleUserInteraction));
        
        function startTutorial() {
            tutorialActive = true; tutorialCompleted = false; currentTutorialStep = 0;
            tutorialOverlay.classList.add('active'); tutorialOverlay.classList.remove('idle-hint');
            tutorialProgress.innerHTML = '';
            tutorialSteps.forEach((_, i) => {
                const dot = document.createElement('div');
                dot.className = 'tutorial-dot' + (i === 0 ? ' active' : '');
                tutorialProgress.appendChild(dot);
            });
            showTutorialStep(0);
        }
        
        function showTutorialStep(stepIndex) {
            if (stepIndex >= tutorialSteps.length) { endTutorial(); return; }
            const step = tutorialSteps[stepIndex];
            const targetEl = document.getElementById(step.target);
            const rect = targetEl.getBoundingClientRect();
            tutorialSpotlight.style.left = (rect.left - 8) + 'px';
            tutorialSpotlight.style.top = (rect.top - 8) + 'px';
            tutorialSpotlight.style.width = (rect.width + 16) + 'px';
            tutorialSpotlight.style.height = (rect.height + 16) + 'px';
            const arrows = { below: '‚ñ≤', above: '‚ñº', left: '‚ñ∂', right: '‚óÄ' };
            tutorialArrow.textContent = arrows[step.position];
            tutorialArrowContainer.className = 'tutorial-arrow-container position-' + step.position;
            let arrowX, arrowY;
            switch (step.position) {
                case 'below': arrowX = rect.left + rect.width / 2; arrowY = rect.bottom + 8; tutorialArrowContainer.style.transform = 'translate(-50%, 0)'; break;
                case 'above': arrowX = rect.left + rect.width / 2; arrowY = rect.top - 8; tutorialArrowContainer.style.transform = 'translate(-50%, -100%)'; break;
                case 'left': arrowX = rect.left - 8; arrowY = rect.top + rect.height / 2; tutorialArrowContainer.style.transform = 'translate(-100%, -50%)'; break;
                case 'right': arrowX = rect.right + 8; arrowY = rect.top + rect.height / 2; tutorialArrowContainer.style.transform = 'translate(0, -50%)'; break;
            }
            tutorialArrowContainer.style.left = arrowX + 'px';
            tutorialArrowContainer.style.top = arrowY + 'px';
            tutorialText.innerHTML = step.text + '<small>Tap to continue</small>';
            const dots = tutorialProgress.querySelectorAll('.tutorial-dot');
            dots.forEach((dot, i) => { dot.classList.remove('active', 'completed'); if (i < stepIndex) dot.classList.add('completed'); else if (i === stepIndex) dot.classList.add('active'); });
            if (tutorialAutoTimer) clearTimeout(tutorialAutoTimer);
            tutorialAutoTimer = setTimeout(advanceTutorial, 5000);
        }
        
        function advanceTutorial() { if (!tutorialActive) return; currentTutorialStep++; if (currentTutorialStep >= tutorialSteps.length) endTutorial(); else showTutorialStep(currentTutorialStep); }
        function endTutorial() { tutorialActive = false; tutorialCompleted = true; tutorialOverlay.classList.remove('active'); if (tutorialAutoTimer) clearTimeout(tutorialAutoTimer); resetIdleTimer(); }
        
        tutorialOverlay.addEventListener('click', () => { if (idleHintActive) hideIdleHint(); else advanceTutorial(); });
        tutorialArrowContainer.addEventListener('click', (e) => { e.stopPropagation(); if (idleHintActive) hideIdleHint(); else advanceTutorial(); });
        window.addEventListener('load', () => { setTimeout(startTutorial, 500); updateStageProgressBar(); });
        
        // ==================== OIL SYSTEM GEOMETRY ====================
        const oilSystem = {
            panX: 270, panY: 405, panWidth: 500, panHeight: 70,
            panBottomY: 475,
            pickupX: 320, pickupTopY: 395, pickupBottomY: 465,
            pickupWidth: 12,
            pickupScreenWidth: 30,
            pumpX: 295, pumpY: 360, pumpWidth: 50, pumpHeight: 35,
            mainGalleryY: 340,
            mainGalleryLeft: 280,
            mainGalleryRight: 750,
            cylinderFeeds: [320, 400, 480, 560, 640, 720],
            feedTopY: 275,
            airBubbles: []
        };
        
        // ==================== PARTICLE CLASSES ====================
        class FrictionParticle {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                if (type === 'smoke') {
                    this.vx = (Math.random() - 0.5) * 0.5;
                    this.vy = -Math.random() * 0.8 - 0.2;
                    this.life = 1.0; this.decay = 0.015;
                    this.size = 1 + Math.random() * 1.5;
                } else if (type === 'flash') {
                    this.vx = (Math.random() - 0.5) * 3;
                    this.vy = (Math.random() - 0.5) * 5;
                    this.life = 1.0; this.decay = 0.12;
                    this.size = 4 + Math.random() * 4;
                    this.colorPhase = Math.random() * 0.3;
                } else {
                    this.vx = (Math.random() - 0.5) * 4;
                    this.vy = (Math.random() - 0.5) * 8;
                    this.life = 1.0; this.decay = 0.08;
                    this.size = 2 + Math.random() * 3;
                }
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                if (this.type === 'smoke') { this.vx *= 0.95; this.vy *= 0.95; this.size += 0.06; }
                else if (this.type === 'flash') { this.colorPhase = Math.min(1, this.colorPhase + 0.15); }
                else { this.vy += 0.25; }
                this.life -= this.decay;
                return this.life > 0;
            }
            draw(ctx) {
                if (this.type === 'smoke') {
                    ctx.fillStyle = `rgba(140, 140, 140, ${this.life * 0.6})`;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                } else if (this.type === 'flash') {
                    const r = 255, g = Math.floor(255 * (1 - this.colorPhase));
                    ctx.fillStyle = `rgba(${r}, ${g}, ${g}, ${this.life})`;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2); ctx.fill();
                } else {
                    ctx.fillStyle = `rgba(255, ${Math.floor(100 * this.life)}, 0, ${this.life})`;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                }
            }
        }
        
        class WindageParticle {
            constructor(cx, cy, angle, speed) {
                this.x = cx; this.y = cy;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0; this.decay = 0.02 + Math.random() * 0.01;
                this.size = 1.5 + Math.random() * 1.5;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vy += 0.15;
                this.life -= this.decay;
                if (this.y > oilSystem.panBottomY) return false;
                return this.life > 0;
            }
            draw(ctx) {
                ctx.fillStyle = `rgba(0, 0, 0, ${this.life * 0.6})`;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            }
        }
        
        class DrainbackParticle {
            constructor(x, y) {
                this.x = x + (Math.random() - 0.5) * 20;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = 0.5 + Math.random() * 1;
                this.life = 1.0; this.decay = 0.008;
                this.size = 2 + Math.random() * 2;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vy += 0.1;
                this.life -= this.decay;
                if (this.y > oilSystem.panBottomY) return false;
                return this.life > 0;
            }
            draw(ctx) {
                ctx.fillStyle = `rgba(0, 0, 0, ${this.life * 0.5})`;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            }
        }
        
        class AirBubble {
            constructor(x, y) {
                this.x = x + (Math.random() - 0.5) * (oilSystem.pickupWidth * 0.6);
                this.y = y;
                this.vy = -0.8 - Math.random() * 1;
                this.life = 1.0; this.decay = 0.025;
                this.size = 1 + Math.random() * 1.5;
            }
            update() {
                this.y += this.vy;
                this.x += Math.sin(this.y * 0.15) * 0.3;
                this.life -= this.decay;
                return this.life > 0 && this.y > oilSystem.pumpY;
            }
            draw(ctx) {
                ctx.fillStyle = `rgba(255, 255, 255, ${this.life * 0.9})`;
                ctx.strokeStyle = `rgba(180, 180, 180, ${this.life * 0.7})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }
        
        // ==================== CYLINDER CLASS ====================
        class Cylinder {
            constructor(x, y, angle, phaseOffset, bank, index) {
                this.x = x; this.y = y;
                this.baseAngle = angle; this.angle = angle;
                this.phaseOffset = phaseOffset;
                this.bank = bank; this.index = index;
                this.pistonPos = 0; this.prevPistonPos = 0;
                this.pistonWarpAngle = 0;
                this.intakeValveOpen = 0; this.exhaustValveOpen = 0;
                this.strokePhase = 0;
            }
            update(crankAngle, rpmReductionPercent) {
                const adjustedAngle = (crankAngle + this.phaseOffset) % 720;
                this.prevPistonPos = this.pistonPos;
                this.pistonPos = Math.sin((adjustedAngle * Math.PI) / 360) * 35;
                this.strokePhase = Math.floor(adjustedAngle / 180);
                this.pistonWarpAngle = 10 * (rpmReductionPercent / 100) * ((this.index % 2 === 0) ? 1 : -1);
                this.angle = this.baseAngle;
                this.intakeValveOpen = adjustedAngle < 180 ? Math.sin((adjustedAngle * Math.PI) / 180) * 12 : 0;
                this.exhaustValveOpen = adjustedAngle >= 540 ? Math.sin(((adjustedAngle - 540) * Math.PI) / 180) * 12 : 0;
            }
            draw(ctx, engineState) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate((this.angle * Math.PI) / 180);
                const damageShake = engineState.damageStage > 2 ? (Math.random() - 0.5) * engineState.damageStage * 1.5 : 0;
                const heatLevel = engineState.heat, lubeLevel = engineState.lubrication, damageLevel = engineState.damageStage;
                let strokeColor = '#000', fillColor = '#fff', pistonFillColor = '#fff';
                if (heatLevel > 70) pistonFillColor = `rgb(255, ${Math.floor(255 - (heatLevel - 70) / 30 * 200)}, ${Math.floor(255 - (heatLevel - 70) / 30 * 200)})`;
                if (damageLevel >= 4) { strokeColor = '#880000'; fillColor = '#ffeeee'; }
                else if (damageLevel >= 2) { strokeColor = '#aa0000'; fillColor = '#fff8f8'; }
                
                ctx.strokeStyle = strokeColor; ctx.fillStyle = fillColor; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.rect(-30 + damageShake, -90, 60, 130); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.rect(-35 + damageShake, -105, 70, 20); ctx.fill(); ctx.stroke();
                ctx.fillStyle = heatLevel > 60 ? '#fff0f0' : '#f5f5f5';
                ctx.beginPath(); ctx.rect(-25 + damageShake, -85, 50, 15); ctx.fill(); ctx.stroke();
                ctx.fillStyle = fillColor;
                ctx.beginPath(); ctx.rect(-20 + damageShake, -100 + this.intakeValveOpen, 6, 20); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(-17 + damageShake, -100 + this.intakeValveOpen, 8, 3, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.rect(14 + damageShake, -100 + this.exhaustValveOpen, 6, 20); ctx.fill(); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(17 + damageShake, -100 + this.exhaustValveOpen, 8, 3, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                
                const pistonY = this.pistonPos;
                ctx.save();
                ctx.translate(damageShake, pistonY + 7);
                ctx.rotate((this.pistonWarpAngle * Math.PI) / 180);
                ctx.fillStyle = pistonFillColor; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.rect(-25, -15, 50, 30); ctx.fill(); ctx.stroke();
                const lubeFactor = Math.max(0, (lubeLevel - 30) / 70);
                if (lubeFactor > 0.02) {
                    ctx.strokeStyle = `rgba(0, 0, 0, ${Math.pow(lubeFactor, 1.5)})`;
                    ctx.lineWidth = 2 + lubeFactor * 4; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(-25, -12); ctx.lineTo(-25, 11); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(25, -12); ctx.lineTo(25, 11); ctx.stroke();
                }
                ctx.strokeStyle = strokeColor; ctx.lineWidth = 1.5;
                for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.moveTo(-25, -9 + i * 8); ctx.lineTo(25, -9 + i * 8); ctx.stroke(); }
                ctx.fillStyle = fillColor; ctx.beginPath(); ctx.arc(0, 8, 5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.restore();
                
                ctx.lineWidth = 8; ctx.strokeStyle = fillColor;
                ctx.beginPath(); ctx.moveTo(damageShake, pistonY + 22); ctx.lineTo(damageShake, 68); ctx.stroke();
                ctx.lineWidth = 6; ctx.strokeStyle = strokeColor;
                ctx.beginPath(); ctx.moveTo(damageShake, pistonY + 22); ctx.lineTo(damageShake, 68); ctx.stroke();
                
                if (heatLevel > 60) {
                    const pistonMoving = Math.abs(this.pistonPos - this.prevPistonPos) > 0.5;
                    const intensity = (heatLevel - 60) / 40;
                    if (pistonMoving) {
                        for (let s = 0; s < 10; s++) {
                            if (Math.random() < intensity * 0.8) {
                                const side = Math.random() > 0.5 ? -25 : 25;
                                const sy = pistonY + (Math.random() - 0.5) * 28;
                                const rad = (this.angle * Math.PI) / 180;
                                engine.frictionParticles.push(new FrictionParticle(
                                    this.x + side * Math.cos(rad) - sy * Math.sin(rad),
                                    this.y + side * Math.sin(rad) + sy * Math.cos(rad), 'smoke'));
                            }
                        }
                    }
                }
                
                const strokeNames = ['IN', 'COMP', 'PWR', 'EXH'];
                ctx.fillStyle = strokeColor; ctx.font = 'bold 9px Helvetica'; ctx.textAlign = 'center';
                ctx.fillText(strokeNames[this.strokePhase], damageShake, -112);
                ctx.restore();
            }
        }
        
        const cylinders = [
            new Cylinder(320, 215, -30, 0, 'left', 0),
            new Cylinder(480, 215, -30, 240, 'left', 1),
            new Cylinder(640, 215, -30, 480, 'left', 2),
            new Cylinder(400, 215, 30, 120, 'right', 3),
            new Cylinder(560, 215, 30, 360, 'right', 4),
            new Cylinder(720, 215, 30, 600, 'right', 5),
        ];
        
        // ==================== DRAWING FUNCTIONS ====================
        function drawEngineBlock(ctx) {
            const d = engine.damageStage;
            let strokeColor = '#000', fillColor = '#fff';
            if (d >= 4) { strokeColor = '#880000'; fillColor = '#fff5f5'; }
            else if (d >= 2) { strokeColor = '#aa4444'; }
            ctx.strokeStyle = strokeColor; ctx.fillStyle = fillColor; ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(250, 320); ctx.lineTo(280, 150); ctx.lineTo(520, 115);
            ctx.lineTo(760, 150); ctx.lineTo(790, 320); ctx.lineTo(790, 365);
            ctx.lineTo(250, 365); ctx.closePath();
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = d >= 3 ? '#fff0f0' : '#f8f8f8';
            ctx.beginPath();
            ctx.moveTo(400, 175); ctx.lineTo(520, 145); ctx.lineTo(640, 175);
            ctx.lineTo(640, 250); ctx.lineTo(400, 250); ctx.closePath();
            ctx.fill(); ctx.stroke();
        }
        
        function drawCrankshaft(ctx, angle) {
            const centerX = 520, centerY = 345, d = engine.damageStage;
            const shake = d > 2 ? (Math.random() - 0.5) * d * 2 : 0;
            let strokeColor = d >= 4 ? '#880000' : d >= 2 ? '#aa4444' : '#000';
            ctx.save();
            ctx.translate(centerX + shake, centerY);
            ctx.rotate((angle * Math.PI) / 180);
            ctx.strokeStyle = strokeColor; ctx.fillStyle = '#fff'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(0, 0, 28, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.stroke();
            for (let i = 0; i < 6; i++) {
                const ta = (i * 60 + 30) * Math.PI / 180;
                const tx = Math.cos(ta) * 45, ty = Math.sin(ta) * 45;
                ctx.lineWidth = 10; ctx.strokeStyle = '#fff';
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(tx * 0.75, ty * 0.75); ctx.stroke();
                ctx.lineWidth = 8; ctx.strokeStyle = strokeColor;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(tx * 0.75, ty * 0.75); ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(tx, ty, 10, 0, Math.PI * 2); ctx.fill();
                ctx.lineWidth = 2; ctx.stroke();
            }
            ctx.restore();
            
            if (engine.lubrication > 20 && engine.isRunning) {
                const rpmFactor = engine.rpm / 3000;
                if (Math.random() < 0.3 * rpmFactor) {
                    const ta = (angle * Math.PI / 180) + Math.random() * Math.PI * 2;
                    const sp = 2 + Math.random() * 3 * rpmFactor;
                    const sd = 35 + Math.random() * 15;
                    engine.windageParticles.push(new WindageParticle(centerX + Math.cos(ta) * sd, centerY + Math.sin(ta) * sd, ta, sp));
                }
            }
        }
        
        function drawOilPan(ctx) {
            const { panX, panY, panWidth, panHeight } = oilSystem;
            const oilLevel = engine.oilLevel, isLow = oilLevel < 10;
            ctx.strokeStyle = isLow ? '#cc0000' : '#000';
            ctx.fillStyle = '#fff'; ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(panX, panY);
            ctx.lineTo(panX + 30, panY + panHeight);
            ctx.lineTo(panX + panWidth - 30, panY + panHeight);
            ctx.lineTo(panX + panWidth, panY);
            ctx.closePath();
            ctx.fill(); ctx.stroke();
            
            const critY = panY + panHeight - ((10 / 100) * (panHeight - 12)) - 5;
            ctx.strokeStyle = '#cc0000'; ctx.lineWidth = 1.5; ctx.setLineDash([4, 4]);
            ctx.beginPath(); ctx.moveTo(panX + 40, critY); ctx.lineTo(panX + panWidth - 40, critY); ctx.stroke();
            ctx.setLineDash([]);
            
            const maxH = panHeight - 12, oilH = (oilLevel / 100) * maxH;
            if (oilH > 0) {
                ctx.fillStyle = isLow ? '#cc0000' : '#000';
                const oilY = panY + panHeight - oilH - 5;
                const inset = 30 * (1 - oilH / panHeight);
                ctx.beginPath();
                ctx.moveTo(panX + 35 + inset, oilY);
                ctx.lineTo(panX + panWidth - 35 - inset, oilY);
                ctx.lineTo(panX + panWidth - 35, panY + panHeight - 5);
                ctx.lineTo(panX + 35, panY + panHeight - 5);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = isLow ? '#ff6666' : '#333'; ctx.lineWidth = 1;
                const time = Date.now() / 400;
                ctx.beginPath();
                for (let x = panX + 40; x < panX + panWidth - 40; x += 3) {
                    const wy = oilY + Math.sin(x / 15 + time) * 2;
                    if (x === panX + 40) ctx.moveTo(x, wy); else ctx.lineTo(x, wy);
                }
                ctx.stroke();
            }
            ctx.fillStyle = '#000'; ctx.font = '10px Helvetica'; ctx.textAlign = 'left';
            ctx.fillText('F', panX + panWidth + 10, panY + 15);
            ctx.fillText('E', panX + panWidth + 10, panY + panHeight - 5);
            ctx.fillStyle = '#fff'; ctx.strokeStyle = isLow ? '#cc0000' : '#000'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(panX + panWidth / 2, panY + panHeight, 6, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
        }
        
        function drawOilPumpAndPickup(ctx) {
            const { pickupX, pickupTopY, pickupBottomY, pickupWidth, pickupScreenWidth, pumpX, pumpY, pumpWidth, pumpHeight, panY, panHeight } = oilSystem;
            const oilLevel = engine.oilLevel, isLow = oilLevel < 10;
            const isFlowing = oilLevel >= 10 && engine.lubrication > 10;
            const flowAlpha = Math.min(1, engine.lubrication / 50);
            
            const maxH = panHeight - 12, oilH = (oilLevel / 100) * maxH;
            const oilSurfaceY = panY + panHeight - oilH - 5;
            const pickupScreenY = pickupBottomY - 8;
            engine.pumpSuckingAir = pickupScreenY < oilSurfaceY;
            
            // Pickup tube with animated flow (UPWARD direction) or gray when not flowing
            if (isFlowing) {
                drawAnimatedPickupTube(ctx, pickupX, pumpY + pumpHeight, pickupBottomY - 15, pickupWidth, flowAlpha);
            } else {
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.6)';
                ctx.lineWidth = pickupWidth;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(pickupX, pumpY + pumpHeight);
                ctx.lineTo(pickupX, pickupBottomY - 15);
                ctx.stroke();
            }
            
            // Pickup screen
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = isLow ? '#cc0000' : '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(pickupX - pickupScreenWidth/2, pickupBottomY - 15, pickupScreenWidth, 12, 3);
            ctx.fill(); ctx.stroke();
            ctx.strokeStyle = isLow ? '#ffaaaa' : '#999'; ctx.lineWidth = 0.5;
            for (let x = pickupX - pickupScreenWidth/2 + 3; x < pickupX + pickupScreenWidth/2 - 3; x += 4) {
                ctx.beginPath(); ctx.moveTo(x, pickupBottomY - 13); ctx.lineTo(x, pickupBottomY - 5); ctx.stroke();
            }
            
            // Oil pump
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = isLow ? '#cc0000' : '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(pumpX, pumpY, pumpWidth, pumpHeight, 4);
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = isLow ? '#cc0000' : '#000';
            ctx.font = 'bold 8px Helvetica'; ctx.textAlign = 'center';
            ctx.fillText('OIL', pumpX + pumpWidth/2, pumpY + 14);
            ctx.fillText('PUMP', pumpX + pumpWidth/2, pumpY + 24);
            
            // "SUCKING AIR" warning text - only when oil < 10%
            if (isLow && engine.isRunning) {
                if (engine.suckingAirFlashOn) {
                    ctx.fillStyle = '#cc0000';
                    ctx.font = 'bold 9px Helvetica';
                    ctx.textAlign = 'left';
                    ctx.fillText('SUCKING', pickupX + 22, pickupBottomY - 25);
                    ctx.fillText('AIR', pickupX + 22, pickupBottomY - 14);
                }
            }
            
            // Air bubbles only when oil >= 10% (some oil still being drawn but about to run out)
            // When < 10%, no bubbles - just nothing coming through
            if (engine.pumpSuckingAir && engine.isRunning && oilLevel >= 10 && Math.random() < 0.4) {
                oilSystem.airBubbles.push(new AirBubble(pickupX, pickupBottomY - 20));
            }
        }
        
        function drawAnimatedPickupTube(ctx, x, topY, bottomY, width, alpha) {
            const segmentLength = 20;
            // Reverse offset for upward flow
            const offset = (30 - (engine.galleryFlowOffset % 30));
            
            // Base tube
            ctx.strokeStyle = `rgba(60, 60, 60, ${alpha})`;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x, topY);
            ctx.lineTo(x, bottomY);
            ctx.stroke();
            
            // Animated flow (UPWARD direction - pulses move from bottom to top)
            const tubeLength = bottomY - topY;
            for (let d = (offset % segmentLength); d < tubeLength; d += segmentLength) {
                const py = bottomY - d; // Start from bottom, go up
                ctx.fillStyle = `rgba(30, 30, 30, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(x, py, width * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Upward arrow
            const midY = (topY + bottomY) / 2;
            ctx.save();
            ctx.translate(x, midY);
            ctx.rotate(-Math.PI / 2); // Point up
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
            ctx.beginPath();
            ctx.moveTo(6, 0);
            ctx.lineTo(-3, -4);
            ctx.lineTo(-3, 4);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        
        function drawOilGalleries(ctx) {
            const { mainGalleryY, mainGalleryLeft, mainGalleryRight, cylinderFeeds, feedTopY, pumpX, pumpWidth, pumpY } = oilSystem;
            const isFlowing = engine.oilLevel >= 10 && engine.lubrication > 10;
            const flowAlpha = Math.min(1, engine.lubrication / 50);
            
            if (isFlowing && engine.isRunning) {
                engine.galleryFlowOffset = (engine.galleryFlowOffset + 3) % 30;
            }
            
            const galleryWidth = isFlowing ? 6 : 4;
            
            if (isFlowing) {
                drawAnimatedGallery(ctx, 
                    [{x: pumpX + pumpWidth, y: pumpY + 10}, {x: pumpX + pumpWidth + 20, y: mainGalleryY}, {x: mainGalleryRight, y: mainGalleryY}],
                    galleryWidth, flowAlpha, true);
                drawAnimatedGallery(ctx,
                    [{x: mainGalleryLeft, y: mainGalleryY}, {x: pumpX + pumpWidth + 20, y: mainGalleryY}],
                    galleryWidth, flowAlpha, false);
            } else {
                ctx.strokeStyle = `rgba(150, 150, 150, 0.4)`;
                ctx.lineWidth = galleryWidth; ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(pumpX + pumpWidth, pumpY + 10);
                ctx.lineTo(pumpX + pumpWidth + 20, mainGalleryY);
                ctx.lineTo(mainGalleryRight, mainGalleryY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(mainGalleryLeft, mainGalleryY);
                ctx.lineTo(pumpX + pumpWidth + 20, mainGalleryY);
                ctx.stroke();
            }
            
            cylinderFeeds.forEach((feedX) => {
                if (isFlowing) {
                    drawAnimatedGallery(ctx,
                        [{x: feedX, y: mainGalleryY}, {x: feedX, y: feedTopY}],
                        galleryWidth - 1, flowAlpha, true);
                    ctx.fillStyle = `rgba(0, 0, 0, ${flowAlpha * 0.6})`;
                    ctx.beginPath(); ctx.arc(feedX, feedTopY, 5, 0, Math.PI * 2); ctx.fill();
                } else {
                    ctx.strokeStyle = `rgba(150, 150, 150, 0.4)`;
                    ctx.lineWidth = galleryWidth - 1;
                    ctx.beginPath(); ctx.moveTo(feedX, mainGalleryY); ctx.lineTo(feedX, feedTopY); ctx.stroke();
                }
            });
            
            if (isFlowing && engine.isRunning && Math.random() < 0.1) {
                const feedX = cylinderFeeds[Math.floor(Math.random() * cylinderFeeds.length)];
                engine.drainbackParticles.push(new DrainbackParticle(feedX, feedTopY + 50));
            }
        }
        
        function drawAnimatedGallery(ctx, points, width, alpha, showArrows) {
            const segmentLength = 30, offset = engine.galleryFlowOffset;
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.strokeStyle = `rgba(60, 60, 60, ${alpha})`;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.stroke();
            
            for (let i = 1; i < points.length; i++) {
                const p1 = points[i-1], p2 = points[i];
                const dx = p2.x - p1.x, dy = p2.y - p1.y;
                const segDist = Math.sqrt(dx*dx + dy*dy);
                const angle = Math.atan2(dy, dx);
                for (let d = (offset % segmentLength); d < segDist; d += segmentLength) {
                    const t = d / segDist;
                    ctx.fillStyle = `rgba(30, 30, 30, ${alpha * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(p1.x + dx * t, p1.y + dy * t, width * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
                if (showArrows && segDist > 40) {
                    const midX = p1.x + dx * 0.5, midY = p1.y + dy * 0.5;
                    ctx.save();
                    ctx.translate(midX, midY);
                    ctx.rotate(angle);
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
                    ctx.beginPath();
                    ctx.moveTo(6, 0); ctx.lineTo(-3, -4); ctx.lineTo(-3, 4); ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
            }
        }
        
        function drawParticles(ctx) {
            engine.frictionParticles = engine.frictionParticles.filter(p => p.update());
            engine.frictionParticles.forEach(p => p.draw(ctx));
            engine.windageParticles = engine.windageParticles.filter(p => p.update());
            engine.windageParticles.forEach(p => p.draw(ctx));
            engine.drainbackParticles = engine.drainbackParticles.filter(p => p.update());
            engine.drainbackParticles.forEach(p => p.draw(ctx));
            oilSystem.airBubbles = oilSystem.airBubbles.filter(b => b.update());
            oilSystem.airBubbles.forEach(b => b.draw(ctx));
        }
        
        // ==================== ENGINE UPDATE ====================
        function updateEngine() {
            if (engine.damageStage >= 5) {
                engine.isRunning = false; engine.rpm = 0;
                engine.lubrication = 0; engine.heat = 0;
            }
            engine.rpmReductionPercent = engine.damageStage >= 5 ? 100 : Math.round((engine.damageStage * 400) / 3000 * 100);
            if (engine.isRunning) {
                engine.crankAngle = (engine.crankAngle + 12 * engine.rpm / 3000) % 720;
                cylinders.forEach(cyl => cyl.update(engine.crankAngle, engine.rpmReductionPercent));
            }
            if (engine.statsFrozen || engine.damageStage >= 5) { updateUI(); return; }
            
            const effects = damageEffects[engine.damageStage];
            if (engine.oilLevel >= 10) {
                engine.lubrication = Math.min(100, engine.lubrication + (100 - engine.lubrication) * 0.03);
            } else {
                const factor = (10 - engine.oilLevel) / 10;
                engine.lubrication = Math.max(0, engine.lubrication - ((20 + factor * 13.3) / 60) * effects.lubeLossMult);
            }
            
            if (engine.lubrication < 50) {
                const factor = (50 - engine.lubrication) / 50;
                engine.heat = Math.min(100, engine.heat + ((1 + factor * 32) / 60) * effects.heatMult * (1 + engine.rpm / 3000 * engine.damageStage * 0.1));
            } else {
                engine.heat = Math.max(0, engine.heat - engine.heat * (engine.oilLevel >= 50 ? 0.04 : engine.oilLevel >= 10 ? 0.025 : 0.01));
            }
            
            if (engine.isRunning) {
                const targetRPM = 3000 - engine.damageStage * 400 - (engine.heat > 80 ? 500 : 0);
                engine.rpm = Math.max(0, engine.rpm + (targetRPM - engine.rpm) * 0.05);
            }
            
            if (engine.heat > 90 && engine.damageStage < 5 && !engine.countdownActive && !engine.damagePopupVisible && !engine.infoPopupVisible && !engine.graceActive) {
                if (idleHintActive) hideIdleHint();
                startCountdown();
            }
            if (engine.countdownActive && engine.heat < 80) cancelCountdown(true);
            updateUI();
        }
        
        function updateUI() {
            const isSeized = engine.damageStage >= 5, isOilCrit = engine.oilLevel < 10;
            const isLubLow = engine.lubrication < 30, isHeatHigh = engine.heat > 60, isWarpHigh = engine.warping > 30;
            
            // Check Oil (amber) - below 25%
            checkOilLight.classList.toggle('active', engine.oilLevel < 25);
            
            // Oil Pressure (red) - below 10%
            oilPressureLight.classList.toggle('active', engine.oilLevel < 10);
            
            // Check Engine (amber) - Stage 2 intermittent, Stage 3+ solid
            checkEngineLight.classList.remove('active', 'intermittent');
            if (engine.damageStage >= 3) {
                checkEngineLight.classList.add('active');
            } else if (engine.damageStage === 2 || engine.damageStage === 1) {
                checkEngineLight.classList.add('active', 'intermittent');
            }
            
            oilSliderFill.style.width = engine.oilLevel + '%';
            oilSliderBall.style.left = engine.oilLevel + '%';
            oilPercent.textContent = Math.round(engine.oilLevel);
            oilSliderFill.classList.toggle('low', isOilCrit);
            oilSliderBall.classList.toggle('low', isOilCrit);
            oilPercentage.classList.toggle('low', isOilCrit);
            oilSection.classList.toggle('warning', isOilCrit);
            oilWarningIcon.style.display = isOilCrit ? 'inline' : 'none';
            refillOilOverlay.classList.toggle('active', engine.countdownActive);
            
            const dLube = isSeized ? 0 : engine.lubrication, dHeat = isSeized ? 0 : engine.heat;
            lubMeter.style.width = dLube + '%';
            lubValue.textContent = Math.round(dLube) + '%';
            lubMeter.classList.toggle('critical', isLubLow && !isSeized);
            lubValue.classList.toggle('critical', isLubLow && !isSeized);
            lubMeterContainer.classList.toggle('critical', isLubLow && !isSeized);
            
            heatMeter.style.width = dHeat + '%';
            heatValue.textContent = Math.round(dHeat) + '%';
            heatMeter.classList.toggle('critical', isHeatHigh && !isSeized);
            heatValue.classList.toggle('critical', isHeatHigh && !isSeized);
            heatMeterContainer.classList.toggle('critical', isHeatHigh && !isSeized);
            
            warpMeter.style.width = engine.warping + '%';
            warpValue.textContent = Math.round(engine.warping) + '%';
            warpMeter.classList.toggle('critical', isWarpHigh);
            warpValue.classList.toggle('critical', isWarpHigh);
            warpMeterContainer.classList.toggle('critical', isWarpHigh);
            
            const stage = damageStages[engine.damageStage];
            damageStageEl.textContent = stage.name;
            damageStageEl.className = 'hud-status-stage ' + stage.color;
            statusText.textContent = stage.description;
            hudStatus.classList.toggle('critical', engine.damageStage > 0);
            
            const problems = stageProblems[engine.damageStage];
            if (problems.length === 0) hudProblems.classList.remove('visible');
            else {
                hudProblems.classList.add('visible');
                problemsList.innerHTML = '';
                problems.forEach(p => { const li = document.createElement('li'); li.innerHTML = `<span class="problem-x">‚úï</span> ${p}`; problemsList.appendChild(li); });
            }
            
            conditionText.textContent = stageConditions[engine.damageStage];
            hudCondition.classList.toggle('critical', engine.damageStage >= 3);
            engineWrapper.classList.toggle('warning', engine.countdownActive || engine.damageStage >= 3);
            
            engineRPM.textContent = Math.round(engine.rpm);
            engineRPM.classList.toggle('critical', engine.rpm < 2000);
            if (engine.rpmReductionPercent > 0) { rpmReduction.textContent = `-${engine.rpmReductionPercent}%`; rpmReduction.classList.add('visible'); }
            else rpmReduction.classList.remove('visible');
            
            updateStageProgressBar();
        }
        
        // ==================== COUNTDOWN ====================
        function startCountdown() {
            engine.countdownActive = true; engine.countdownValue = 3;
            if (idleHintActive) hideIdleHint();
            showCountdownNumber(3);
            engine.countdownTimer = setInterval(() => {
                engine.countdownValue--;
                if (engine.countdownValue > 0) showCountdownNumber(engine.countdownValue);
                else { clearInterval(engine.countdownTimer); engine.countdownActive = false; refillOilOverlay.classList.remove('active'); triggerDamage(); }
            }, 1000);
        }
        
        function cancelCountdown(showSuccess = false) {
            if (engine.countdownTimer) clearInterval(engine.countdownTimer);
            engine.countdownActive = false;
            countdownNumber.classList.remove('visible');
            refillOilOverlay.classList.remove('active');
            if (showSuccess) {
                successCheckmark.classList.remove('visible'); void successCheckmark.offsetWidth; successCheckmark.classList.add('visible');
                successFlash.classList.remove('active'); void successFlash.offsetWidth; successFlash.classList.add('active');
            }
        }
        
        function showCountdownNumber(num) {
            countdownNumber.textContent = num;
            countdownNumber.classList.remove('visible'); void countdownNumber.offsetWidth; countdownNumber.classList.add('visible');
            warningFlash.classList.remove('active'); void warningFlash.offsetWidth; warningFlash.classList.add('active');
        }
        
        function triggerDamage() {
            if (engine.damageStage >= 5) return;
            engine.damageStage++;
            if (engine.warpAppliedAtStage < engine.damageStage) {
                engine.warping = Math.min(100, engine.warping + warpIncrements[engine.damageStage]);
                engine.warpAppliedAtStage = engine.damageStage;
            }
            engine.statsFrozen = true;
            if (idleHintActive) hideIdleHint();
            showDamagePopup();
        }
        
        // ==================== RENDER ====================
        function render() {
            const rect = engineWrapper.getBoundingClientRect();
            const dw = rect.width, dh = rect.height;
            ctx.clearRect(0, 0, dw, dh);
            ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, dw, dh);
            ctx.save();
            const scaleX = dw / CANVAS_WIDTH, scaleY = dh / CANVAS_HEIGHT;
            const baseScale = Math.min(scaleX, scaleY) * zoom.baseScale;
            const currentScale = (zoom.level / zoom.baseScale) * baseScale;
            ctx.translate(dw / 2, dh / 2);
            ctx.scale(currentScale, currentScale);
            ctx.translate(-ENGINE_CENTER_X + zoom.offsetX, -ENGINE_CENTER_Y + zoom.offsetY);
            
            drawEngineBlock(ctx);
            drawOilGalleries(ctx);
            drawOilPan(ctx);
            drawOilPumpAndPickup(ctx);
            drawCrankshaft(ctx, engine.crankAngle);
            cylinders.forEach(cyl => cyl.draw(ctx, engine));
            drawParticles(ctx);
            ctx.restore();
        }
        
        function gameLoop() {
            updateZoom(); updateEngine(); render();
            requestAnimationFrame(gameLoop);
        }
        
        // ==================== OIL SLIDER ====================
        let isDragging = false;
        function updateOilFromPosition(clientX) {
            const rect = oilSliderTrack.getBoundingClientRect();
            engine.oilLevel = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
            resetIdleTimer();
        }
        
        oilSliderTrack.addEventListener('mousedown', (e) => { isDragging = true; updateOilFromPosition(e.clientX); });
        oilSliderBall.addEventListener('mousedown', (e) => { isDragging = true; e.preventDefault(); });
        document.addEventListener('mousemove', (e) => { if (isDragging) updateOilFromPosition(e.clientX); });
        document.addEventListener('mouseup', () => { isDragging = false; });
        oilSliderTrack.addEventListener('touchstart', (e) => { isDragging = true; updateOilFromPosition(e.touches[0].clientX); });
        oilSliderBall.addEventListener('touchstart', (e) => { isDragging = true; e.preventDefault(); });
        document.addEventListener('touchmove', (e) => { if (isDragging) updateOilFromPosition(e.touches[0].clientX); });
        document.addEventListener('touchend', () => { isDragging = false; });
        
        refillBtn.addEventListener('click', () => { engine.oilLevel = 100; resetIdleTimer(); });
        resetBtn.addEventListener('click', () => {
            engine.oilLevel = 100; engine.lubrication = 100; engine.heat = 0; engine.warping = 0;
            engine.damageStage = 0; engine.warpAppliedAtStage = -1; engine.rpm = 3000;
            engine.rpmReductionPercent = 0; engine.isRunning = true; engine.statsFrozen = false;
            engine.damagePopupVisible = false; engine.infoPopupVisible = false; engine.graceActive = false;
            engine.frictionParticles = []; engine.windageParticles = []; engine.drainbackParticles = [];
            oilSystem.airBubbles = [];
            cylinders.forEach(cyl => { cyl.angle = cyl.baseAngle; cyl.pistonWarpAngle = 0; });
            cancelCountdown(false);
            infoOverlay.classList.remove('visible');
            refillOilOverlay.classList.remove('active');
            resetIdleTimer();
        });
        
        gameLoop();
    </script>
</body>
</html>
