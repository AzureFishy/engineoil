<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>V6 Engine Lubrication Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            color: #000;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        header {
            text-align: center;
            padding: 8px 0;
            border-bottom: 2px solid #000;
        }

        h1 { font-size: clamp(16px, 4vw, 24px); font-weight: 600; letter-spacing: -0.5px; }
        .subtitle { color: #666; font-size: clamp(10px, 2.5vw, 13px); margin-top: 3px; }

        /* ==================== ENGINE CANVAS ==================== */
        .engine-canvas-wrapper {
            position: relative;
            background: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            overflow: hidden;
            flex-grow: 1;
            touch-action: none;
            min-height: 340px;
        }
        .engine-canvas-wrapper.warning { border-color: #cc0000; box-shadow: 0 0 20px rgba(204, 0, 0, 0.3); }

        #engineCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            background: #fff;
            cursor: zoom-in;
        }
        #engineCanvas.zoomed { cursor: zoom-out; }

        /* ==================== WARNING LIGHTS (SVG Icons) ==================== */
        .warning-lights-top {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
        }

        .warning-light {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            opacity: 0.08;
            transition: opacity 0.3s ease;
        }
        .warning-light.active { opacity: 1; }

        .warning-light .icon-container {
            position: relative;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .warning-light .icon {
            width: 28px;
            height: 28px;
        }
        .warning-light .label {
            font-size: 6px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }

        /* Check Oil - Amber */
        .warning-light.check-oil .icon .oil-can-body { stroke: #666; }
        .warning-light.check-oil .icon .oil-can-drop { fill: #666; }
        .warning-light.check-oil .label { color: #666; }
        .warning-light.check-oil.active .icon .oil-can-body { stroke: #ff9900; }
        .warning-light.check-oil.active .icon .oil-can-drop { fill: #ff9900; }
        .warning-light.check-oil.active .label { color: #ff9900; }

        /* Oil Pressure - Red */
        .warning-light.oil-pressure .icon .oil-can-body { stroke: #666; }
        .warning-light.oil-pressure .icon .oil-can-drop { fill: #666; }
        .warning-light.oil-pressure .label { color: #666; }
        .warning-light.oil-pressure.active .icon .oil-can-body { stroke: #cc0000; }
        .warning-light.oil-pressure.active .icon .oil-can-drop { fill: #cc0000; }
        .warning-light.oil-pressure.active .label { color: #cc0000; }

        /* Check Engine - Amber */
        .warning-light.check-engine .icon .engine-body { stroke: #666; }
        .warning-light.check-engine .label { color: #666; }
        .warning-light.check-engine.active .icon .engine-body { stroke: #ff9900; }
        .warning-light.check-engine.active .label { color: #ff9900; }
        
        /* Pending state - subtle flashing at ~10% opacity */
        .warning-light.pending {
            animation: pendingFlash 1.5s ease-in-out infinite;
        }
        .warning-light.pending.check-oil .icon .oil-can-body { stroke: #ff9900; }
        .warning-light.pending.check-oil .icon .oil-can-drop { fill: #ff9900; }
        .warning-light.pending.check-oil .label { color: #ff9900; }
        .warning-light.pending.oil-pressure .icon .oil-can-body { stroke: #cc0000; }
        .warning-light.pending.oil-pressure .icon .oil-can-drop { fill: #cc0000; }
        .warning-light.pending.oil-pressure .label { color: #cc0000; }
        .warning-light.pending.check-engine .icon .engine-body { stroke: #ff9900; }
        .warning-light.pending.check-engine .label { color: #ff9900; }

        @keyframes pendingFlash {
            0%, 100% { opacity: 0.06; }
            50% { opacity: 0.15; }
        }


        /* ==================== HUD PANELS ==================== */
        .hud-left-panel {
            position: absolute;
            top: 8px; left: 8px;
            width: clamp(100px, 18vw, 160px);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .hud-right-panel {
            position: absolute;
            top: 8px; right: 8px; bottom: 8px;
            width: clamp(90px, 16vw, 140px);
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 10;
        }

        .hud-box {
            background: #fff;
            border: 1px solid #000;
            border-radius: 4px;
            padding: 6px 8px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .hud-box:hover { background: #f8f8f8; }
        .hud-box.critical { border-color: #cc0000; background: #fff5f5; }
        .hud-box.critical:hover { background: #fff0f0; }
        
        /* Unified damage stage styling for left panel boxes */
        .hud-left-panel.damage-stage-1 .hud-box { border-color: #cc0000; }
        .hud-left-panel.damage-stage-2 .hud-box { border-color: #cc0000; background: rgba(204, 0, 0, 0.03); }
        .hud-left-panel.damage-stage-3 .hud-box { border-color: #cc0000; background: rgba(204, 0, 0, 0.06); }
        .hud-left-panel.damage-stage-4 .hud-box { border-color: #cc0000; background: rgba(204, 0, 0, 0.10); }
        .hud-left-panel.damage-stage-5 .hud-box { border-color: #cc0000; background: rgba(204, 0, 0, 0.15); }
        .hud-left-panel.damage-stage-1 .hud-box:hover,
        .hud-left-panel.damage-stage-2 .hud-box:hover,
        .hud-left-panel.damage-stage-3 .hud-box:hover,
        .hud-left-panel.damage-stage-4 .hud-box:hover,
        .hud-left-panel.damage-stage-5 .hud-box:hover { background: rgba(204, 0, 0, 0.08); }

        .hud-label {
            font-size: 7px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666;
            margin-bottom: 2px;
        }

        .hud-status { text-align: center; }
        .hud-status-stage {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            transition: color 0.3s ease;
        }
        .hud-status-stage.stage-1 { color: #996600; }
        .hud-status-stage.stage-2 { color: #cc4400; }
        .hud-status-stage.stage-3 { color: #cc0000; }
        .hud-status-stage.stage-4 { color: #aa0000; font-weight: 800; }
        .hud-status-stage.stage-5 { color: #880000; animation: criticalPulse 0.5s infinite; }

        @keyframes criticalPulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        .hud-status-text { font-size: 8px; color: #666; margin-top: 2px; }

        .hud-problems { display: none; border-color: #cc0000; }
        .hud-problems.visible { display: block; }
        .hud-problems:hover { background: #fff8f8; }
        .hud-problems-list { list-style: none; }
        .hud-problems-list li {
            font-size: 8px;
            color: #cc0000;
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .hud-problems-list li:last-child { margin-bottom: 0; }
        .problem-x { font-weight: 700; font-size: 9px; }

        .hud-condition-text { font-size: 8px; color: #333; line-height: 1.3; text-align: left; }
        .hud-box.critical .hud-condition-text { color: #cc0000; }

        .hud-rpm { text-align: center; padding: 5px 8px; }
        .hud-rpm-value-container { display: flex; align-items: flex-start; justify-content: center; gap: 6px; }
        .hud-rpm-value {
            font-size: clamp(14px, 3vw, 20px);
            font-weight: 700;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            line-height: 1.2;
            transition: color 0.3s ease;
        }
        .hud-rpm-value.critical { color: #cc0000; }
        .hud-rpm-reduction {
            font-size: clamp(8px, 1.5vw, 10px);
            font-weight: 600;
            color: #cc0000;
            font-family: 'SF Mono', monospace;
            margin-top: 3px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .hud-rpm-reduction.visible { opacity: 1; }

        /* ==================== HUD METERS ==================== */
        .hud-meters { display: flex; flex-direction: column; gap: 5px; flex-grow: 1; }

        .hud-meter {
            display: flex;
            align-items: stretch;
            gap: 0;
            cursor: pointer;
        }
        .hud-meter:hover .hud-meter-content { background: #f8f8f8; }
        .hud-meter.critical:hover .hud-meter-content { background: #fff0f0; }

        .hud-meter-warning {
            width: 16px;
            background: #cc0000;
            border-radius: 4px 0 0 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .hud-meter.critical .hud-meter-warning { opacity: 1; animation: warningFlash 1s infinite; }
        .hud-meter.critical .hud-meter-warning { border: 1px solid #cc0000; border-right: none; }
        .hud-meter-warning-icon { color: #fff; font-size: 10px; font-weight: bold; }

        @keyframes warningFlash { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }

        .hud-meter-content {
            flex: 1;
            background: #fff;
            border: 1px solid #000;
            border-radius: 4px;
            padding: 5px 8px;
            transition: all 0.3s ease;
        }
        .hud-meter.critical .hud-meter-content { border-color: #cc0000; border-left: none; border-radius: 0 4px 4px 0; }

        .hud-meter-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px; }
        .hud-meter-label { font-size: 8px; text-transform: uppercase; letter-spacing: 0.5px; color: #666; font-weight: 600; }
        .hud-meter-value {
            font-size: 10px;
            font-weight: 700;
            font-family: 'SF Mono', monospace;
            transition: color 0.3s ease;
        }
        .hud-meter-value.critical { color: #cc0000; }

        .hud-meter-bar-container {
            height: 6px;
            background: #eee;
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid #ddd;
        }
        .hud-meter-bar {
            height: 100%;
            border-radius: 2px;
            background: #000;
            transition: width 0.3s ease, background 0.3s ease;
        }
        .hud-meter-bar.critical { background: #cc0000; }

        /* ==================== STAGE PROGRESS BAR ==================== */
        .stage-progress-container {
            background: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .stage-progress-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #666;
            text-align: center;
            font-weight: 600;
        }
        .stage-progress-bar { display: flex; position: relative; height: 32px; }

        .stage-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            position: relative;
            padding-bottom: 2px;
        }
        .stage-indicator {
            position: absolute;
            top: 2px;
            font-size: 10px;
            font-weight: 700;
            color: #cc0000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .stage-item.damaged .stage-indicator { opacity: 1; }
        .stage-item.nominal-past .stage-indicator { opacity: 1; color: #999; }
        .stage-name {
            font-size: clamp(7px, 1.8vw, 9px);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            color: #999;
            transition: color 0.3s ease;
        }
        .stage-item.current .stage-name { color: #666; }
        .stage-item.damaged .stage-name { color: #cc0000; }
        .stage-item.nominal-past .stage-name { color: #999; }

        .stage-arrow {
            position: absolute;
            top: -12px;
            font-size: 16px;
            font-weight: 900;
            color: #000;
            z-index: 100;
            text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff,
                         -1px 0 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, 0 1px 0 #fff;
            animation: arrowBob 1s ease-in-out infinite;
            pointer-events: none;
        }
        @keyframes arrowBob { 0%, 100% { transform: translateX(-50%) translateY(0); } 50% { transform: translateX(-50%) translateY(-4px); } }

        .stage-divider { width: 1px; background: #ddd; height: 100%; position: absolute; right: 0; top: 0; }
        .stage-item:last-child .stage-divider { display: none; }

        /* ==================== OVERLAYS ==================== */
        .overlay-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 20;
        }

        .countdown-number {
            font-size: clamp(120px, 35vw, 250px);
            font-weight: 900;
            color: #cc0000;
            opacity: 0;
            transform: scale(2);
            font-family: 'SF Mono', monospace;
            position: absolute;
            text-shadow: -3px -3px 0 #fff, 3px -3px 0 #fff, -3px 3px 0 #fff, 3px 3px 0 #fff,
                         -3px 0 0 #fff, 3px 0 0 #fff, 0 -3px 0 #fff, 0 3px 0 #fff,
                         0 0 40px rgba(204, 0, 0, 0.6), 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        .countdown-number.active { animation: countdownPulse 1s ease-out forwards; }
        @keyframes countdownPulse {
            0% { transform: scale(2); opacity: 0; }
            15% { transform: scale(1); opacity: 1; }
            85% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0; }
        }

        .success-checkmark {
            font-size: clamp(100px, 30vw, 200px);
            color: #00aa44;
            opacity: 0;
            transform: scale(0.5);
            position: absolute;
            text-shadow: -3px -3px 0 #fff, 3px -3px 0 #fff, -3px 3px 0 #fff, 3px 3px 0 #fff,
                         -3px 0 0 #fff, 3px 0 0 #fff, 0 -3px 0 #fff, 0 3px 0 #fff,
                         0 0 40px rgba(0, 170, 68, 0.6), 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        .success-checkmark.active { animation: checkmarkPop 1.2s ease-out forwards; }
        @keyframes checkmarkPop {
            0% { transform: scale(0.5); opacity: 0; }
            20% { transform: scale(1.2); opacity: 1; }
            40%, 80% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0; }
        }

        /* Friction hint text - shows during countdown */
        .friction-hint {
            position: absolute;
            top: auto;
            bottom: 12%;
            font-size: clamp(16px, 5vw, 28px);
            font-weight: 700;
            color: #cc0000;
            opacity: 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: -2px -2px 0 #fff, 2px -2px 0 #fff, -2px 2px 0 #fff, 2px 2px 0 #fff,
                         -2px 0 0 #fff, 2px 0 0 #fff, 0 -2px 0 #fff, 0 2px 0 #fff,
                         0 0 20px rgba(204, 0, 0, 0.4);
            pointer-events: none;
        }
        .friction-hint.active {
            opacity: 1;
            animation: frictionSway 2s ease-in-out infinite;
        }
        @keyframes frictionSway {
            0%, 100% { transform: translateX(-15px); }
            50% { transform: translateX(15px); }
        }

        /* Friction success text - shows with checkmark */
        .friction-success {
            position: absolute;
            top: auto;
            bottom: 12%;
            font-size: clamp(14px, 4vw, 22px);
            font-weight: 700;
            color: #00aa44;
            opacity: 0;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            text-shadow: -2px -2px 0 #fff, 2px -2px 0 #fff, -2px 2px 0 #fff, 2px 2px 0 #fff,
                         -2px 0 0 #fff, 2px 0 0 #fff, 0 -2px 0 #fff, 0 2px 0 #fff,
                         0 0 20px rgba(0, 170, 68, 0.4);
            pointer-events: none;
        }
        .friction-success.active { animation: frictionSuccessPop 1.2s ease-out forwards; }
        @keyframes frictionSuccessPop {
            0% { opacity: 0; transform: scale(0.8); }
            20% { opacity: 1; transform: scale(1.05); }
            40%, 80% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.9); }
        }

        .flash-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            opacity: 0;
            z-index: 15;
        }
        .flash-overlay.warning { background: rgba(204, 0, 0, 0.12); }
        .flash-overlay.success { background: rgba(0, 170, 68, 0.15); }
        .flash-overlay.active { animation: flashOverlay 0.3s ease-out; }
        @keyframes flashOverlay { 0%, 100% { opacity: 0; } 50% { opacity: 1; } }

        .info-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.75);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 25;
        }
        .info-overlay.visible { opacity: 1; pointer-events: auto; cursor: pointer; }

        .info-overlay-content {
            background: #fff;
            padding: clamp(16px, 4vw, 40px) clamp(20px, 5vw, 50px);
            border: 3px solid #000;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            width: clamp(240px, 70%, 450px);
        }
        .info-overlay.damage-mode .info-overlay-content { border-color: #cc0000; }

        .info-overlay-title {
            font-size: clamp(16px, 4vw, 28px);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .info-overlay.damage-mode .info-overlay-title { color: #cc0000; }

        .info-overlay-stage {
            font-size: clamp(12px, 3vw, 20px);
            font-weight: 700;
            margin-bottom: 12px;
        }
        .info-overlay.damage-mode .info-overlay-stage { color: #cc0000; }

        .info-overlay-description { font-size: clamp(10px, 2.5vw, 14px); color: #333; line-height: 1.5; margin-bottom: 16px; text-align: left; }
        .info-overlay-tap { font-size: clamp(9px, 2vw, 12px); color: #888; font-style: italic; }

        /* ==================== TUTORIAL ==================== */
        .tutorial-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 100;
            display: none;
            cursor: pointer;
        }
        .tutorial-overlay.active { display: block; }

        .tutorial-spotlight {
            position: absolute;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            pointer-events: none;
            transition: all 0.4s ease;
        }

        .tutorial-arrow-container {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.4s ease;
        }
        .tutorial-arrow-container.position-below { flex-direction: column; }
        .tutorial-arrow-container.position-above { flex-direction: column-reverse; }
        .tutorial-arrow-container.position-left { flex-direction: row-reverse; }
        .tutorial-arrow-container.position-right { flex-direction: row; }

        .tutorial-arrow {
            font-size: 60px;
            font-weight: 900;
            color: #000;
            line-height: 1;
            text-shadow: -2px -2px 0 #fff, 2px -2px 0 #fff, -2px 2px 0 #fff, 2px 2px 0 #fff,
                         -2px 0 0 #fff, 2px 0 0 #fff, 0 -2px 0 #fff, 0 2px 0 #fff,
                         0 0 10px rgba(255, 255, 255, 0.8);
        }
        .tutorial-arrow-container.position-below .tutorial-arrow { animation: arrowBounceDown 1s ease-in-out infinite; }
        .tutorial-arrow-container.position-above .tutorial-arrow { animation: arrowBounceUp 1s ease-in-out infinite; }
        .tutorial-arrow-container.position-left .tutorial-arrow { animation: arrowBounceLeft 1s ease-in-out infinite; }
        .tutorial-arrow-container.position-right .tutorial-arrow { animation: arrowBounceRight 1s ease-in-out infinite; }

        @keyframes arrowBounceDown { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(15px); } }
        @keyframes arrowBounceUp { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        @keyframes arrowBounceLeft { 0%, 100% { transform: translateX(0); } 50% { transform: translateX(-15px); } }
        @keyframes arrowBounceRight { 0%, 100% { transform: translateX(0); } 50% { transform: translateX(15px); } }

        .tutorial-text {
            background: #fff;
            padding: 12px 18px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #333;
            max-width: 250px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: 2px solid #000;
        }
        .tutorial-text small { display: block; margin-top: 6px; font-size: 11px; color: #888; }

        .tutorial-progress {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 101;
        }
        .tutorial-dot {
            width: 10px; height: 10px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #000;
            transition: all 0.3s ease;
        }
        .tutorial-dot.active { background: #000; transform: scale(1.2); }
        .tutorial-dot.completed { background: #00aa44; border-color: #00aa44; }
        .tutorial-overlay.idle-hint .tutorial-progress { display: none; }

        /* ==================== OIL SLIDER ==================== */
        .oil-slider-row { display: flex; gap: 10px; align-items: stretch; }

        .oil-slider-container {
            flex: 1;
            background: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            padding: 10px 16px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .oil-slider-container.warning { border-color: #cc0000; box-shadow: 0 0 15px rgba(204, 0, 0, 0.2); }

        .refill-oil-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(204, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            z-index: 5;
            border-radius: 6px;
        }
        .refill-oil-overlay.active { animation: refillFlash 0.5s ease-in-out infinite; }
        @keyframes refillFlash { 0%, 100% { opacity: 0.9; } 50% { opacity: 0.5; } }

        .refill-oil-text {
            color: #fff;
            font-size: clamp(16px, 4vw, 24px);
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .oil-slider-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .oil-slider-title {
            font-size: clamp(10px, 2.5vw, 12px);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .warning-icon { color: #cc0000; animation: blink 0.5s infinite; }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

        .oil-percentage {
            font-size: clamp(18px, 5vw, 28px);
            font-weight: 700;
            font-family: 'SF Mono', monospace;
            transition: color 0.3s ease;
        }
        .oil-percentage.low { color: #cc0000; }

        .oil-slider-track-wrapper { position: relative; }
        .oil-slider-track {
            height: clamp(14px, 3vw, 20px);
            background: #e8e8e8;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            border: 1px solid #ccc;
            touch-action: none;
        }

        .critical-line, .check-oil-line {
            position: absolute;
            top: -4px; bottom: -4px;
            width: 0;
            pointer-events: none;
            z-index: 2;
        }
        .critical-line { left: 10%; border-left: 2px dashed #cc0000; }
        .check-oil-line { left: 25%; border-left: 2px dashed #dd8800; }

        .oil-slider-fill {
            position: absolute;
            left: 0; top: 0;
            height: 100%;
            background: linear-gradient(90deg, #333, #000);
            border-radius: 9px;
            transition: width 0.1s ease;
        }
        .oil-slider-fill.low { background: linear-gradient(90deg, #cc0000, #ff4444); }

        .oil-slider-ball {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: clamp(24px, 6vw, 34px);
            height: clamp(24px, 6vw, 34px);
            background: #fff;
            border: 3px solid #000;
            border-radius: 50%;
            cursor: grab;
            transition: box-shadow 0.2s ease, border-color 0.3s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            z-index: 3;
            touch-action: none;
        }
        .oil-slider-ball:hover { box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); }
        .oil-slider-ball:active { cursor: grabbing; }
        .oil-slider-ball.low { border-color: #cc0000; }

        .slider-labels { display: flex; justify-content: space-between; font-size: clamp(8px, 2vw, 10px); color: #999; margin-top: 6px; }

        .buttons-container { display: flex; gap: 6px; }
        .btn {
            width: clamp(50px, 10vw, 80px);
            height: 100%;
            background: #000;
            color: #fff;
            border: 2px solid #000;
            border-radius: 8px;
            font-size: clamp(8px, 2vw, 10px);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }
        .btn:hover { background: #333; border-color: #333; }
        .btn:active { background: #555; }
        .btn-icon { font-size: clamp(16px, 4vw, 22px); }

        /* ==================== FOOTER ==================== */
        .site-footer {
            margin-top: 15px;
            padding: 0 10px 10px 10px;
        }
        .footer-divider {
            height: 1px;
            background: linear-gradient(to right, transparent, #ccc 20%, #ccc 80%, transparent);
            margin-bottom: 12px;
        }
        .footer-content {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
            font-size: 11px;
            color: #999;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .footer-copyright {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .footer-separator {
            color: #ccc;
            margin: 0 2px;
        }
        .footer-author {
            color: #666;
        }
        .footer-link {
            color: #888;
            text-decoration: none;
            transition: color 0.2s ease;
        }
        .footer-link:hover {
            color: #555;
            text-decoration: underline;
        }
        .footer-version {
            font-family: 'SF Mono', 'Monaco', 'Consolas', 'Liberation Mono', monospace;
            font-size: 10px;
            color: #aaa;
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* ==================== RESPONSIVE ==================== */
        @media (min-width: 601px), (orientation: landscape) {
            .container { padding-left: 5%; padding-right: 5%; }
            .engine-canvas-wrapper { min-height: 390px; }
        }

        @media (max-width: 600px) and (orientation: portrait) {
            .engine-canvas-wrapper { min-height: 36vh; }
            .hud-left-panel { left: 4px; width: clamp(80px, 22vw, 110px); }
            .hud-right-panel { right: 4px; width: clamp(70px, 20vw, 100px); }
            .tutorial-text { max-width: 250px; }
            .warning-lights-top { gap: 12px; }
            .warning-light .icon-container { width: 22px; height: 22px; }
            .warning-light .icon { width: 22px; height: 22px; }
            .warning-light .label { font-size: 5px; }
        }

        @media (max-width: 500px) {
            .warning-lights-top { gap: 10px; }
            .warning-light .icon-container { width: 20px; height: 20px; }
            .warning-light .icon { width: 20px; height: 20px; }
            .warning-light .label { font-size: 5px; }
            .hud-box { padding: 4px 6px; }
            .hud-status-stage { font-size: 9px; }
            .hud-problems-list li { font-size: 7px; }
            .hud-condition-text { font-size: 7px; }
            .hud-rpm-value { font-size: 14px; }
            .hud-rpm-reduction { font-size: 7px; }
            .hud-meter-content { padding: 4px 6px; }
            .hud-meter-label { font-size: 6px; }
            .hud-meter-value { font-size: 8px; }
            .hud-meter-bar-container { height: 4px; }
            .hud-meter-warning { width: 12px; }
            .hud-meter-warning-icon { font-size: 8px; }
            .tutorial-text { font-size: 12px; padding: 10px 14px; }
            .tutorial-arrow { font-size: 45px; }
            .info-overlay-content { padding: 12px 16px; }
            .info-overlay-title { font-size: 14px; }
            .info-overlay-stage { font-size: 11px; }
            .info-overlay-description { font-size: 10px; }
            .buttons-container { gap: 4px; }
            .btn { width: clamp(45px, 12vw, 70px); }
            .stage-progress-container { padding: 6px 8px; }
            .stage-name { font-size: 7px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Engine Oil Simulation</h1>
            <p class="subtitle">Interactive demonstration of a V6 engine operation and oil system failure</p>
        </header>
        
        <div class="engine-canvas-wrapper" id="engineWrapper">
            <canvas id="engineCanvas"></canvas>
            
            <div class="warning-lights-top">
                <!-- Check Oil - Amber oil can -->
                <div class="warning-light check-oil" data-light="checkOil">
                    <div class="icon-container">
                        <svg class="icon" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                            <g class="oil-can-body" fill="none" stroke-width="7" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M 16 42 L 10 70 Q 10 78, 20 78 L 50 78 Q 56 78, 56 72 L 56 56 L 72 44 L 72 38 L 56 50 L 56 42 Q 56 36, 50 36 L 42 36 L 42 26 Q 42 20, 34 20 L 24 20 Q 18 20, 18 26 L 18 36 Q 10 36, 10 42 L 16 42"/>
                            </g>
                            <path class="oil-can-drop" d="M 80 48 L 87 68 Q 87 76, 80 76 Q 73 76, 73 68 L 80 48 Z"/>
                        </svg>
                    </div>
                    <span class="label">Check Oil</span>
                </div>
                
                <!-- Oil Pressure - Red oil can -->
                <div class="warning-light oil-pressure" data-light="oilPressure">
                    <div class="icon-container">
                        <svg class="icon" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                            <g class="oil-can-body" fill="none" stroke-width="7" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M 16 42 L 10 70 Q 10 78, 20 78 L 50 78 Q 56 78, 56 72 L 56 56 L 72 44 L 72 38 L 56 50 L 56 42 Q 56 36, 50 36 L 42 36 L 42 26 Q 42 20, 34 20 L 24 20 Q 18 20, 18 26 L 18 36 Q 10 36, 10 42 L 16 42"/>
                            </g>
                            <path class="oil-can-drop" d="M 80 48 L 87 68 Q 87 76, 80 76 Q 73 76, 73 68 L 80 48 Z"/>
                        </svg>
                    </div>
                    <span class="label">Oil Pressure</span>
                </div>
                
                <!-- Check Engine - Amber engine -->
                <div class="warning-light check-engine" data-light="checkEngine">
                    <div class="icon-container">
                        <svg class="icon" viewBox="0 0 100 80" xmlns="http://www.w3.org/2000/svg">
                            <g class="engine-body" fill="none" stroke-width="8" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M 20 28 L 20 60 Q 20 66, 26 66 L 74 66 Q 80 66, 80 60 L 80 28 Q 80 22, 74 22 L 62 22 L 62 14 Q 62 10, 58 10 L 42 10 Q 38 10, 38 14 L 38 22 L 26 22 Q 20 22, 20 28"/>
                                <path d="M 20 32 L 14 32 L 14 38 L 8 38 L 8 52 L 14 52 L 14 58 L 20 58"/>
                                <path d="M 80 34 L 84 34 Q 92 34, 92 44 L 92 54 Q 92 64, 84 64 L 80 64"/>
                            </g>
                        </svg>
                    </div>
                    <span class="label">Check</span>
                </div>
            </div>
            
            <div class="hud-left-panel" id="hudLeftPanel">
                <div class="hud-box hud-status" data-info="status">
                    <div class="hud-label">Eng. Status</div>
                    <div class="hud-status-stage" id="damageStage">PERFECT</div>
                    <div class="hud-status-text" id="statusText">1: Nominal</div>
                </div>
                <div class="hud-box hud-problems" id="hudProblems" data-info="problems">
                    <ul class="hud-problems-list" id="problemsList"></ul>
                </div>
                <div class="hud-box hud-condition" data-info="condition">
                    <div class="hud-condition-text" id="conditionText">Engine running at peak performance.</div>
                </div>
            </div>
            
            <div class="hud-right-panel" id="hudRightPanel">
                <div class="hud-box hud-rpm" data-info="rpm">
                    <div class="hud-label">RPM</div>
                    <div class="hud-rpm-value-container">
                        <div class="hud-rpm-value" id="rpmValue">3000</div>
                        <div class="hud-rpm-reduction" id="rpmReduction">-0%</div>
                    </div>
                </div>
                <div class="hud-meters">
                    <div class="hud-meter" data-meter="lube" data-info="lube">
                        <div class="hud-meter-warning"><span class="hud-meter-warning-icon">‚ö†</span></div>
                        <div class="hud-meter-content">
                            <div class="hud-meter-header">
                                <span class="hud-meter-label">Lube</span>
                                <span class="hud-meter-value">100%</span>
                            </div>
                            <div class="hud-meter-bar-container"><div class="hud-meter-bar" style="width: 100%"></div></div>
                        </div>
                    </div>
                    <div class="hud-meter" data-meter="friction" data-info="friction">
                        <div class="hud-meter-warning"><span class="hud-meter-warning-icon">‚ö†</span></div>
                        <div class="hud-meter-content">
                            <div class="hud-meter-header">
                                <span class="hud-meter-label">Friction</span>
                                <span class="hud-meter-value">0%</span>
                            </div>
                            <div class="hud-meter-bar-container"><div class="hud-meter-bar" style="width: 0%"></div></div>
                        </div>
                    </div>
                    <div class="hud-meter" data-meter="warp" data-info="warp">
                        <div class="hud-meter-warning"><span class="hud-meter-warning-icon">‚ö†</span></div>
                        <div class="hud-meter-content">
                            <div class="hud-meter-header">
                                <span class="hud-meter-label">Mtl. Warp</span>
                                <span class="hud-meter-value">0%</span>
                            </div>
                            <div class="hud-meter-bar-container"><div class="hud-meter-bar" style="width: 0%"></div></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="overlay-container">
                <div class="countdown-number" id="countdownNumber">3</div>
                <div class="friction-hint" id="frictionHint">Reduce Friction</div>
                <div class="success-checkmark" id="successCheckmark">‚úì</div>
                <div class="friction-success" id="frictionSuccess">Friction reduced!</div>
            </div>
            <div class="flash-overlay warning" id="warningFlash"></div>
            <div class="flash-overlay success" id="successFlash"></div>
            <div class="info-overlay" id="infoOverlay">
                <div class="info-overlay-content">
                    <div class="info-overlay-title" id="infoTitle">‚ö† Engine Damage</div>
                    <div class="info-overlay-stage" id="infoStage">Stage 2: WEAR</div>
                    <div class="info-overlay-description" id="infoDescription"></div>
                    <div class="info-overlay-tap">Tap anywhere to continue</div>
                </div>
            </div>
        </div>
        
        <div class="stage-progress-container">
            <div class="stage-progress-label">Damage Progression</div>
            <div class="stage-progress-bar" id="stageProgressBar">
                <div class="stage-arrow" id="stageArrow">‚ñº</div>
                <div class="stage-item current" data-stage="0"><span class="stage-indicator">‚úï</span><span class="stage-name">Nominal</span><div class="stage-divider"></div></div>
                <div class="stage-item" data-stage="1"><span class="stage-indicator">‚úï</span><span class="stage-name">Wear</span><div class="stage-divider"></div></div>
                <div class="stage-item" data-stage="2"><span class="stage-indicator">‚úï</span><span class="stage-name">Bearings</span><div class="stage-divider"></div></div>
                <div class="stage-item" data-stage="3"><span class="stage-indicator">‚úï</span><span class="stage-name">Scoring</span><div class="stage-divider"></div></div>
                <div class="stage-item" data-stage="4"><span class="stage-indicator">‚úï</span><span class="stage-name">Critical</span><div class="stage-divider"></div></div>
                <div class="stage-item" data-stage="5"><span class="stage-indicator">‚úï</span><span class="stage-name">Seized</span></div>
            </div>
        </div>
        
        <div class="oil-slider-row">
            <div class="oil-slider-container" id="oilSection">
                <div class="refill-oil-overlay" id="refillOverlay"><span class="refill-oil-text">‚ö† REFILL OIL ‚ö†</span></div>
                <div class="oil-slider-header">
                    <div class="oil-slider-title">Oil Level<span class="warning-icon" id="oilWarningIcon" style="display: none;">‚ö†</span></div>
                    <div class="oil-percentage" id="oilPercentage"><span id="oilPercent">100</span>%</div>
                </div>
                <div class="oil-slider-track-wrapper">
                    <div class="critical-line"></div>
                    <div class="check-oil-line"></div>
                    <div class="oil-slider-track" id="oilTrack">
                        <div class="oil-slider-fill" id="oilFill"></div>
                        <div class="oil-slider-ball" id="oilBall"></div>
                    </div>
                </div>
                <div class="slider-labels"><span>Empty</span><span>Full</span></div>
            </div>
            <div class="buttons-container">
                <button class="btn" id="refillBtn"><span class="btn-icon">üõ¢Ô∏è</span><span>Refill</span></button>
                <button class="btn" id="resetBtn"><span class="btn-icon">‚öôÔ∏è</span><span>Reset</span></button>
            </div>
        </div>
        
        <footer class="site-footer">
            <div class="footer-divider"></div>
            <div class="footer-content">
                <span class="footer-copyright">¬© 2026 <span class="footer-author">Aaron Harris</span></span>
                <span class="footer-separator">|</span>
                <a href="https://opensource.org/licenses/MIT" class="footer-link" target="_blank" rel="noopener">MIT License</a>
                <span class="footer-separator">|</span>
                <span class="footer-version">v0.36</span>
            </div>
        </footer>
    </div>
    
    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-spotlight" id="tutorialSpotlight"></div>
        <div class="tutorial-arrow-container" id="tutorialArrowContainer">
            <div class="tutorial-arrow" id="tutorialArrow">‚ñº</div>
            <div class="tutorial-text" id="tutorialText">Tutorial<small>Tap to continue</small></div>
        </div>
        <div class="tutorial-progress" id="tutorialProgress"></div>
    </div>

    <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CONFIGURATION & TUNING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const TUNING = {
        oil: { checkOil: 25, pressure: 10, suckingAir: 15, bubbleStart: 25, critical: 10 },
        friction: { countdownStart: 90, countdownCancel: 80, smokeStart: 60 },
        meters: { lubeCritical: 30, frictionCritical: 60, warpCritical: 30 },
        damage: { warpIncrements: [0, 5, 10, 18, 30, 50], rpmLossPerStage: 400, baseRpm: 3000 },
        canvas: { width: 1040, height: 520, centerX: 520, centerY: 280, baseScale: 1.035, zoomedScale: 1.6 },
        blink: { period: 400 }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // DATA DEFINITIONS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const STAGE_DATA = [
        { name: "PERFECT", desc: "1: Nominal", color: "", condition: "Engine running at peak performance.", problems: [] },
        { name: "WEAR", desc: "2: Wear", color: "stage-1", condition: "Minor wear detected, efficiency slightly reduced.", problems: ["-13% RPMs"] },
        { name: "BEARING", desc: "3: Damage", color: "stage-2", condition: "Bearing damage causing increased friction.", problems: ["-27% RPMs", "more friction"] },
        { name: "SCORING", desc: "4: Cylinder", color: "stage-3", condition: "Cylinder scoring with significant metal warping.", problems: ["-40% RPMs", "high friction", "metal warped"] },
        { name: "CRITICAL", desc: "5: Severe", color: "stage-4", condition: "Severe internal damage, failure imminent.", problems: ["-53% RPMs", "major friction", "severe warping"] },
        { name: "SEIZED", desc: "6: Failed", color: "stage-5", condition: "Engine has seized. Replacement required.", problems: ["replace engine"] }
    ];

    const DAMAGE_DESCRIPTIONS = [
        "",
        "<b>Surface wear</b> has formed on cylinder walls from excessive friction. You'll notice <b>reduced RPM capacity</b> and the engine will have a harder time maintaining lubrication.",
        "<b>Main bearings are damaged</b> from friction stress. Friction is now <b>significantly higher</b>, making it harder for oil to properly lubricate moving parts.",
        "<b>Deep scoring marks</b> have formed on cylinder walls from metal-to-metal contact. <b>Permanent metal warping</b> has begun.",
        "<b>Severe internal damage</b> throughout the engine. Connecting rods and crankshaft bearings are <b>compromised</b>.",
        "The engine has <b>completely seized</b>. Pistons have welded to cylinder walls. The engine <b>cannot be repaired</b>."
    ];

    const INFO_CONTENT = {
        rpm: { title: "RPM Meter", text: "<b>RPM</b> shows crankshaft speed. Damage reduces max RPM." },
        lube: { title: "Lubrication", text: "<b>Lubrication</b> measures how well oil is coating the pistons and cylinder walls. When lubrication is high, the pistons glide smoothly without creating damaging friction. Low lubrication means metal-on-metal contact, which rapidly damages your engine." },
        friction: { title: "Friction", text: "<b>Friction</b> shows the wear and heat building up on the pistons from inadequate lubrication. High friction causes the metal components to heat up and expand, leading to warping and permanent damage. This is not engine coolant temperature‚Äîit's localized heat from piston-to-cylinder contact." },
        warp: { title: "Metal Warping", text: "<b>Metal Warping</b> indicates permanent physical deformation of pistons and cylinders caused by excessive friction heat. Warped components no longer fit together properly, causing misalignment, reduced efficiency, and eventually complete engine seizure. This damage cannot be reversed." },
        status: { title: "Engine Status", text: "Shows damage stage from <b>1 (Perfect)</b> to <b>6 (Seized)</b>." },
        problems: { title: "Problems", text: "Lists active issues: RPM loss, friction, warping." },
        condition: { title: "Condition", text: "Summary of engine health and operational status." }
    };

    const METERS_CONFIG = {
        lube: { getValue: () => state.lubrication, threshold: TUNING.meters.lubeCritical, criticalBelow: true },
        friction: { getValue: () => state.friction, threshold: TUNING.meters.frictionCritical, criticalBelow: false },
        warp: { getValue: () => state.warping, threshold: TUNING.meters.warpCritical, criticalBelow: false }
    };

    const LIGHTS_CONFIG = {
        checkOil: () => state.oilLevel < TUNING.oil.checkOil,
        oilPressure: () => state.oilLevel < TUNING.oil.pressure,
        checkEngine: () => state.damageStage >= 2
    };

    const TUTORIAL_STEPS = [
        { target: 'oilSection', position: 'above', text: '<b>Drag this slider</b> to control the <b>oil level</b>. Low oil causes engine damage!' },
        { target: 'hudRightPanel', position: 'left', text: 'Monitor <b>engine stats</b>: <b>RPM</b>, <b>lubrication</b>, <b>friction</b>, and <b>warping</b>.' },
        { target: 'stageProgressBar', position: 'above', text: '<b>Your goal:</b> Experience all <b>6 damage stages</b> by letting the engine overheat!' },
        { target: 'refillBtn', position: 'above', text: 'Use <b>Refill</b> to add oil, or <b>Reset</b> to restore the engine.' }
    ];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // DOM REFERENCES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const DOM = {
        canvas: document.getElementById('engineCanvas'),
        wrapper: document.getElementById('engineWrapper'),
        oilSection: document.getElementById('oilSection'),
        oilTrack: document.getElementById('oilTrack'),
        oilFill: document.getElementById('oilFill'),
        oilBall: document.getElementById('oilBall'),
        oilPercent: document.getElementById('oilPercent'),
        oilPercentage: document.getElementById('oilPercentage'),
        oilWarningIcon: document.getElementById('oilWarningIcon'),
        refillOverlay: document.getElementById('refillOverlay'),
        hudLeftPanel: document.getElementById('hudLeftPanel'),
        damageStage: document.getElementById('damageStage'),
        statusText: document.getElementById('statusText'),
        hudProblems: document.getElementById('hudProblems'),
        problemsList: document.getElementById('problemsList'),
        conditionText: document.getElementById('conditionText'),
        rpmValue: document.getElementById('rpmValue'),
        rpmReduction: document.getElementById('rpmReduction'),
        countdownNumber: document.getElementById('countdownNumber'),
        frictionHint: document.getElementById('frictionHint'),
        successCheckmark: document.getElementById('successCheckmark'),
        frictionSuccess: document.getElementById('frictionSuccess'),
        warningFlash: document.getElementById('warningFlash'),
        successFlash: document.getElementById('successFlash'),
        infoOverlay: document.getElementById('infoOverlay'),
        infoTitle: document.getElementById('infoTitle'),
        infoStage: document.getElementById('infoStage'),
        infoDescription: document.getElementById('infoDescription'),
        stageProgressBar: document.getElementById('stageProgressBar'),
        stageArrow: document.getElementById('stageArrow'),
        stageItems: document.querySelectorAll('.stage-item'),
        tutorialOverlay: document.getElementById('tutorialOverlay'),
        tutorialSpotlight: document.getElementById('tutorialSpotlight'),
        tutorialArrowContainer: document.getElementById('tutorialArrowContainer'),
        tutorialArrow: document.getElementById('tutorialArrow'),
        tutorialText: document.getElementById('tutorialText'),
        tutorialProgress: document.getElementById('tutorialProgress'),
        refillBtn: document.getElementById('refillBtn'),
        resetBtn: document.getElementById('resetBtn'),
        meters: document.querySelectorAll('[data-meter]'),
        lights: document.querySelectorAll('[data-light]'),
        infoTriggers: document.querySelectorAll('[data-info]')
    };

    const ctx = DOM.canvas.getContext('2d');

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ENGINE STATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const state = {
        oilLevel: 100, lubrication: 100, friction: 0, warping: 0,
        damageStage: 0, rpm: 3000, crankAngle: 0,
        isRunning: true, countdownActive: false, countdownValue: 3, countdownTimer: null,
        popupVisible: false, infoVisible: false, graceActive: false, statsFrozen: false,
        warpAppliedAtStage: -1, galleryFlowOffset: 0, pumpSuckingAir: false,
        particles: []
    };

    const zoom = { level: 1, targetLevel: 1, offsetX: 0, offsetY: 0, targetOffsetX: 0, targetOffsetY: 0, isZoomed: false };
    const tutorial = { active: false, completed: false, step: 0, autoTimer: null, idleTimer: null, idleActive: false };
    
    // Warning light delay system - each light has independent delay tracking
    const lightDelays = {
        checkOil: { delay: 0, startTime: 0, state: 'off' },      // state: 'off', 'pending', 'active'
        oilPressure: { delay: 0, startTime: 0, state: 'off' },
        checkEngine: { delay: 0, startTime: 0, state: 'off' }
    };
    
    // Roll a new random delay (1-6 seconds) for a light
    function rollLightDelay(lightKey) {
        lightDelays[lightKey].delay = 1000 + Math.random() * 5000; // 1000-6000ms
    }
    
    // Initialize delays for all lights
    Object.keys(lightDelays).forEach(rollLightDelay);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // HELPERS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const pulse = el => { el.classList.remove('active'); void el.offsetWidth; el.classList.add('active'); };
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const lerp = (a, b, t) => a + (b - a) * t;
    const blink = (period = TUNING.blink.period) => Math.floor(Date.now() / period) % 2 === 0;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CANVAS SETUP
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function resizeCanvas() {
        const rect = DOM.wrapper.getBoundingClientRect();
        DOM.canvas.style.width = rect.width + 'px';
        DOM.canvas.style.height = rect.height + 'px';
        const dpr = window.devicePixelRatio || 1;
        DOM.canvas.width = rect.width * dpr;
        DOM.canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // OIL SYSTEM GEOMETRY
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const oilGeom = {
        panX: 270, panY: 405, panW: 500, panH: 70, panBottom: 475,
        pickupX: 320, pickupTop: 395, pickupBottom: 465, pickupW: 12, screenW: 30,
        pumpX: 295, pumpY: 360, pumpW: 50, pumpH: 35,
        galleryY: 340, galleryLeft: 280, galleryRight: 750,
        feeds: [320, 400, 480, 560, 640, 720], feedTop: 275
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // UNIFIED PARTICLE SYSTEM (with fixed update returns)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const PARTICLE_PRESETS = {
        smoke: {
            init: p => {
                p.vx = (Math.random() - 0.5) * 0.5;
                p.vy = -Math.random() * 0.8 - 0.2;
                p.decay = 0.015;
                p.size = 1 + Math.random() * 1.5;
                p.grow = 0.06;
            },
            update: p => { 
                p.vx *= 0.95; 
                p.vy *= 0.95; 
                p.size += p.grow;
                return true;
            },
            draw: (c, p) => {
                c.fillStyle = `rgba(140,140,140,${p.life * 0.6})`;
                c.beginPath(); c.arc(p.x, p.y, p.size, 0, Math.PI * 2); c.fill();
            }
        },
        windage: {
            init: (p, angle, speed) => {
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
                p.decay = 0.02 + Math.random() * 0.01;
                p.size = 1.5 + Math.random() * 1.5;
                p.gravity = 0.15;
            },
            update: p => { 
                p.vy += p.gravity; 
                return p.y <= oilGeom.panBottom; 
            },
            draw: (c, p) => {
                c.fillStyle = `rgba(0,0,0,${p.life * 0.6})`;
                c.beginPath(); c.arc(p.x, p.y, p.size, 0, Math.PI * 2); c.fill();
            }
        },
        drainback: {
            init: p => {
                p.x += (Math.random() - 0.5) * 20;
                p.vx = (Math.random() - 0.5) * 0.5;
                p.vy = 0.5 + Math.random();
                p.decay = 0.008;
                p.size = 2 + Math.random() * 2;
                p.gravity = 0.1;
            },
            update: p => { 
                p.vy += p.gravity; 
                return p.y <= oilGeom.panBottom; 
            },
            draw: (c, p) => {
                c.fillStyle = `rgba(0,0,0,${p.life * 0.5})`;
                c.beginPath(); c.arc(p.x, p.y, p.size, 0, Math.PI * 2); c.fill();
            }
        },
        bubble: {
            init: p => {
                p.x += (Math.random() - 0.5) * oilGeom.pickupW * 0.6;
                p.vy = -0.8 - Math.random();
                p.decay = 0.025;
                p.size = 1 + Math.random() * 1.5;
                p.wobble = 0;
            },
            update: p => { 
                p.wobble = Math.sin(p.y * 0.15) * 0.3; 
                return p.y >= oilGeom.pumpY; 
            },
            draw: (c, p) => {
                c.fillStyle = `rgba(255,255,255,${p.life * 0.9})`;
                c.strokeStyle = `rgba(180,180,180,${p.life * 0.7})`;
                c.lineWidth = 1;
                c.beginPath(); c.arc(p.x, p.y, p.size, 0, Math.PI * 2); c.fill(); c.stroke();
            }
        }
    };

    function createParticle(type, x, y, ...args) {
        const preset = PARTICLE_PRESETS[type];
        const p = { type, x, y, vx: 0, vy: 0, life: 1, decay: 0.02, size: 2 };
        preset.init(p, ...args);
        return p;
    }

    function updateParticle(p) {
        const preset = PARTICLE_PRESETS[p.type];
        p.x += p.vx + (p.wobble || 0);
        p.y += p.vy;
        p.life -= p.decay;
        const inBounds = preset.update ? preset.update(p) : true;
        return p.life > 0 && inBounds;
    }

    function drawParticle(c, p) {
        PARTICLE_PRESETS[p.type].draw(c, p);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CYLINDER CLASS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    class Cylinder {
        constructor(x, y, angle, phase, index) {
            Object.assign(this, { x, y, baseAngle: angle, phase, index, pistonPos: 0, prevPistonPos: 0, pistonWarp: 0, intakeValve: 0, exhaustValve: 0, strokePhase: 0 });
        }
        update(crankAngle, rpmReduction) {
            const adj = (crankAngle + this.phase) % 720;
            this.prevPistonPos = this.pistonPos;
            this.pistonPos = Math.sin((adj * Math.PI) / 360) * 35;
            this.strokePhase = Math.floor(adj / 180);
            this.pistonWarp = 10 * (rpmReduction / 100) * ((this.index % 2 === 0) ? 1 : -1);
            this.intakeValve = adj < 180 ? Math.sin((adj * Math.PI) / 180) * 12 : 0;
            this.exhaustValve = adj >= 540 ? Math.sin(((adj - 540) * Math.PI) / 180) * 12 : 0;
        }
        draw(c) {
            c.save();
            c.translate(this.x, this.y);
            c.rotate((this.baseAngle * Math.PI) / 180);
            
            const shake = state.damageStage > 2 ? (Math.random() - 0.5) * state.damageStage * 1.5 : 0;
            const { friction: fric, lubrication: lube, damageStage: dmg } = state;
            
            let stroke = '#000', fill = '#fff', pistonFill = '#fff';
            if (fric > 70) pistonFill = `rgb(255,${Math.floor(255 - (fric - 70) / 30 * 200)},${Math.floor(255 - (fric - 70) / 30 * 200)})`;
            if (dmg >= 4) { stroke = '#880000'; fill = '#ffeeee'; }
            else if (dmg >= 2) { stroke = '#aa0000'; fill = '#fff8f8'; }
            
            c.strokeStyle = stroke; c.fillStyle = fill; c.lineWidth = 2;
            c.beginPath(); c.rect(-30 + shake, -90, 60, 130); c.fill(); c.stroke();
            c.beginPath(); c.rect(-35 + shake, -105, 70, 20); c.fill(); c.stroke();
            c.fillStyle = fric > 60 ? '#fff0f0' : '#f5f5f5';
            c.beginPath(); c.rect(-25 + shake, -85, 50, 15); c.fill(); c.stroke();
            
            c.fillStyle = fill;
            c.beginPath(); c.rect(-20 + shake, -100 + this.intakeValve, 6, 20); c.fill(); c.stroke();
            c.beginPath(); c.ellipse(-17 + shake, -100 + this.intakeValve, 8, 3, 0, 0, Math.PI * 2); c.fill(); c.stroke();
            c.beginPath(); c.rect(14 + shake, -100 + this.exhaustValve, 6, 20); c.fill(); c.stroke();
            c.beginPath(); c.ellipse(17 + shake, -100 + this.exhaustValve, 8, 3, 0, 0, Math.PI * 2); c.fill(); c.stroke();
            
            c.save();
            c.translate(shake, this.pistonPos + 7);
            c.rotate((this.pistonWarp * Math.PI) / 180);
            c.fillStyle = pistonFill; c.lineWidth = 2;
            c.beginPath(); c.rect(-25, -15, 50, 30); c.fill(); c.stroke();
            
            const lubeFactor = Math.max(0, (lube - 30) / 70);
            if (lubeFactor > 0.02) {
                c.strokeStyle = `rgba(0,0,0,${Math.pow(lubeFactor, 1.5)})`;
                c.lineWidth = 2 + lubeFactor * 4; c.lineCap = 'round';
                c.beginPath(); c.moveTo(-25, -12); c.lineTo(-25, 11); c.stroke();
                c.beginPath(); c.moveTo(25, -12); c.lineTo(25, 11); c.stroke();
            }
            c.strokeStyle = stroke; c.lineWidth = 1.5;
            for (let i = 0; i < 3; i++) { c.beginPath(); c.moveTo(-25, -9 + i * 8); c.lineTo(25, -9 + i * 8); c.stroke(); }
            c.fillStyle = fill; c.beginPath(); c.arc(0, 8, 5, 0, Math.PI * 2); c.fill(); c.stroke();
            c.restore();
            
            c.lineWidth = 8; c.strokeStyle = fill;
            c.beginPath(); c.moveTo(shake, this.pistonPos + 22); c.lineTo(shake, 68); c.stroke();
            c.lineWidth = 6; c.strokeStyle = stroke;
            c.beginPath(); c.moveTo(shake, this.pistonPos + 22); c.lineTo(shake, 68); c.stroke();
            
            // FRICTION PARTICLES: smoke effects from piston friction
            const pistonMoving = Math.abs(this.pistonPos - this.prevPistonPos) > 0.5;
            if (pistonMoving && fric > TUNING.friction.smokeStart) {
                const intensity = (fric - TUNING.friction.smokeStart) / (100 - TUNING.friction.smokeStart);
                const rad = (this.baseAngle * Math.PI) / 180;
                
                // Spawn smoke particles at piston edges
                for (let s = 0; s < 10; s++) {
                    if (Math.random() < intensity * 0.8) {
                        const side = Math.random() > 0.5 ? -25 : 25;
                        const sy = this.pistonPos + (Math.random() - 0.5) * 28;
                        const worldX = this.x + side * Math.cos(rad) - sy * Math.sin(rad);
                        const worldY = this.y + side * Math.sin(rad) + sy * Math.cos(rad);
                        state.particles.push(createParticle('smoke', worldX, worldY));
                    }
                }
            }
            
            const names = ['IN', 'COMP', 'PWR', 'EXH'];
            c.fillStyle = stroke; c.font = 'bold 9px Helvetica'; c.textAlign = 'center';
            c.fillText(names[this.strokePhase], shake, -112);
            c.restore();
        }
    }

    const cylinders = [
        new Cylinder(320, 215, -30, 0, 0), new Cylinder(480, 215, -30, 240, 1), new Cylinder(640, 215, -30, 480, 2),
        new Cylinder(400, 215, 30, 120, 3), new Cylinder(560, 215, 30, 360, 4), new Cylinder(720, 215, 30, 600, 5)
    ];

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // DRAW MODULE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const Draw = {
        engineBlock(c) {
            const d = state.damageStage;
            const stroke = d >= 4 ? '#880000' : d >= 2 ? '#aa4444' : '#000';
            const fill = d >= 4 ? '#fff5f5' : '#fff';
            c.strokeStyle = stroke; c.fillStyle = fill; c.lineWidth = 3;
            c.beginPath();
            c.moveTo(250, 320); c.lineTo(280, 150); c.lineTo(520, 115);
            c.lineTo(760, 150); c.lineTo(790, 320); c.lineTo(790, 365);
            c.lineTo(250, 365); c.closePath();
            c.fill(); c.stroke();
            c.fillStyle = d >= 3 ? '#fff0f0' : '#f8f8f8';
            c.beginPath();
            c.moveTo(400, 175); c.lineTo(520, 145); c.lineTo(640, 175);
            c.lineTo(640, 250); c.lineTo(400, 250); c.closePath();
            c.fill(); c.stroke();
        },

        crankshaft(c, angle) {
            const cx = 520, cy = 345, d = state.damageStage;
            const shake = d > 2 ? (Math.random() - 0.5) * d * 2 : 0;
            const stroke = d >= 4 ? '#880000' : d >= 2 ? '#aa4444' : '#000';
            
            c.save();
            c.translate(cx + shake, cy);
            c.rotate((angle * Math.PI) / 180);
            c.strokeStyle = stroke; c.fillStyle = '#fff'; c.lineWidth = 2;
            c.beginPath(); c.arc(0, 0, 28, 0, Math.PI * 2); c.fill(); c.stroke();
            c.beginPath(); c.arc(0, 0, 14, 0, Math.PI * 2); c.stroke();
            
            for (let i = 0; i < 6; i++) {
                const ta = (i * 60 + 30) * Math.PI / 180;
                const tx = Math.cos(ta) * 45, ty = Math.sin(ta) * 45;
                c.lineWidth = 10; c.strokeStyle = '#fff';
                c.beginPath(); c.moveTo(0, 0); c.lineTo(tx * 0.75, ty * 0.75); c.stroke();
                c.lineWidth = 8; c.strokeStyle = stroke;
                c.beginPath(); c.moveTo(0, 0); c.lineTo(tx * 0.75, ty * 0.75); c.stroke();
                c.fillStyle = '#fff';
                c.beginPath(); c.arc(tx, ty, 10, 0, Math.PI * 2); c.fill();
                c.lineWidth = 2; c.stroke();
            }
            c.restore();
            
            if (state.lubrication > 20 && state.isRunning && Math.random() < 0.3 * state.rpm / TUNING.damage.baseRpm) {
                const ta = (angle * Math.PI / 180) + Math.random() * Math.PI * 2;
                const sp = 2 + Math.random() * 3 * state.rpm / TUNING.damage.baseRpm;
                const sd = 35 + Math.random() * 15;
                state.particles.push(createParticle('windage', cx + Math.cos(ta) * sd, cy + Math.sin(ta) * sd, ta, sp));
            }
        },

        oilPan(c) {
            const { panX: px, panY: py, panW: pw, panH: ph } = oilGeom;
            const { oilLevel: oil } = state;
            const low = oil < TUNING.oil.critical;
            
            c.strokeStyle = low ? '#cc0000' : '#000';
            c.fillStyle = '#fff'; c.lineWidth = 3;
            c.beginPath();
            c.moveTo(px, py); c.lineTo(px + 30, py + ph); c.lineTo(px + pw - 30, py + ph); c.lineTo(px + pw, py);
            c.closePath(); c.fill(); c.stroke();
            
            const critY = py + ph - ((TUNING.oil.critical / 100) * (ph - 12)) - 5;
            c.strokeStyle = '#cc0000'; c.lineWidth = 1.5; c.setLineDash([4, 4]);
            c.beginPath(); c.moveTo(px + 40, critY); c.lineTo(px + pw - 40, critY); c.stroke();
            c.setLineDash([]);
            
            const maxH = ph - 12, oilH = (oil / 100) * maxH;
            if (oilH > 0) {
                c.fillStyle = low ? '#cc0000' : '#000';
                const oilY = py + ph - oilH - 5;
                const inset = 30 * (1 - oilH / ph);
                c.beginPath();
                c.moveTo(px + 35 + inset, oilY); c.lineTo(px + pw - 35 - inset, oilY);
                c.lineTo(px + pw - 35, py + ph - 5); c.lineTo(px + 35, py + ph - 5);
                c.closePath(); c.fill();
                
                c.strokeStyle = low ? '#ff6666' : '#333'; c.lineWidth = 1;
                const time = Date.now() / 400;
                c.beginPath();
                for (let x = px + 40; x < px + pw - 40; x += 3) {
                    const wy = oilY + Math.sin(x / 15 + time) * 2;
                    x === px + 40 ? c.moveTo(x, wy) : c.lineTo(x, wy);
                }
                c.stroke();
            }
            
            c.fillStyle = '#000'; c.font = '10px Helvetica'; c.textAlign = 'left';
            c.fillText('F', px + pw + 10, py + 15);
            c.fillText('E', px + pw + 10, py + ph - 5);
            
            c.fillStyle = '#fff'; c.strokeStyle = low ? '#cc0000' : '#000'; c.lineWidth = 2;
            c.beginPath(); c.arc(px + pw / 2, py + ph, 6, 0, Math.PI * 2); c.fill(); c.stroke();
        },

        pumpAndPickup(c) {
            const { pickupX: pkX, pickupBottom: pkB, pickupW: pkW, screenW, pumpX, pumpY, pumpW, pumpH, panY, panH } = oilGeom;
            const { oilLevel: oil, lubrication: lube, isRunning } = state;
            const low = oil < TUNING.oil.critical;
            const flowing = oil >= TUNING.oil.critical && lube > 10;
            const alpha = Math.min(1, lube / 50);
            
            const maxH = panH - 12, oilH = (oil / 100) * maxH;
            const oilSurfaceY = panY + panH - oilH - 5;
            state.pumpSuckingAir = (pkB - 8) < oilSurfaceY;
            
            if (flowing) {
                this.animatedTube(c, pkX, pumpY + pumpH, pkB - 15, pkW, alpha);
            } else {
                c.strokeStyle = 'rgba(150,150,150,0.6)';
                c.lineWidth = pkW; c.lineCap = 'round';
                c.beginPath(); c.moveTo(pkX, pumpY + pumpH); c.lineTo(pkX, pkB - 15); c.stroke();
            }
            
            c.fillStyle = '#fff'; c.strokeStyle = low ? '#cc0000' : '#000'; c.lineWidth = 2;
            c.beginPath(); c.roundRect(pkX - screenW/2, pkB - 15, screenW, 12, 3); c.fill(); c.stroke();
            c.strokeStyle = low ? '#ffaaaa' : '#999'; c.lineWidth = 0.5;
            for (let x = pkX - screenW/2 + 3; x < pkX + screenW/2 - 3; x += 4) {
                c.beginPath(); c.moveTo(x, pkB - 13); c.lineTo(x, pkB - 5); c.stroke();
            }
            
            c.fillStyle = '#fff'; c.strokeStyle = low ? '#cc0000' : '#000'; c.lineWidth = 2;
            c.beginPath(); c.roundRect(pumpX, pumpY, pumpW, pumpH, 4); c.fill(); c.stroke();
            c.fillStyle = low ? '#cc0000' : '#000';
            c.font = 'bold 8px Helvetica'; c.textAlign = 'center';
            c.fillText('OIL', pumpX + pumpW/2, pumpY + 14);
            c.fillText('PUMP', pumpX + pumpW/2, pumpY + 24);
            
            if (oil < TUNING.oil.suckingAir && isRunning && blink()) {
                c.fillStyle = '#cc0000';
                c.font = 'bold 8px Helvetica';
                c.textAlign = 'left';
                c.fillText('SUCKING AIR', pkX + 20, pkB - 18);
            }
            
            const bubbleEligible = state.pumpSuckingAir && isRunning && oil >= TUNING.oil.critical && oil <= TUNING.oil.bubbleStart;
            const bubbleRate = bubbleEligible ? 0.05 + (TUNING.oil.bubbleStart - oil) / 15 * 0.45 : 0;
            if (Math.random() < bubbleRate) {
                state.particles.push(createParticle('bubble', pkX, pkB - 20));
            }
        },

        animatedTube(c, x, topY, bottomY, width, alpha) {
            c.strokeStyle = `rgba(60,60,60,${alpha})`;
            c.lineWidth = width; c.lineCap = 'round';
            c.beginPath(); c.moveTo(x, topY); c.lineTo(x, bottomY); c.stroke();
            
            const len = bottomY - topY;
            for (let d = state.galleryFlowOffset % 20; d < len; d += 20) {
                c.fillStyle = `rgba(30,30,30,${alpha * 0.8})`;
                c.beginPath(); c.arc(x, bottomY - d, width * 0.4, 0, Math.PI * 2); c.fill();
            }
            
            const midY = (topY + bottomY) / 2;
            c.save();
            c.translate(x, midY);
            c.rotate(-Math.PI / 2);
            c.fillStyle = `rgba(255,255,255,${alpha * 0.9})`;
            c.beginPath(); c.moveTo(6, 0); c.lineTo(-3, -4); c.lineTo(-3, 4); c.closePath(); c.fill();
            c.restore();
        },

        galleries(c) {
            const { galleryY: gy, galleryLeft: gl, galleryRight: gr, feeds, feedTop, pumpX, pumpW, pumpY } = oilGeom;
            const flowing = state.oilLevel >= TUNING.oil.critical && state.lubrication > 10;
            const alpha = Math.min(1, state.lubrication / 50);
            
            if (flowing && state.isRunning) state.galleryFlowOffset = (state.galleryFlowOffset + 3) % 30;
            
            const gw = flowing ? 6 : 4;
            
            if (flowing) {
                this.animatedGallery(c, [{x: pumpX + pumpW, y: pumpY + 10}, {x: pumpX + pumpW + 20, y: gy}, {x: gr, y: gy}], gw, alpha, true);
                this.animatedGallery(c, [{x: gl, y: gy}, {x: pumpX + pumpW + 20, y: gy}], gw, alpha, false);
            } else {
                c.strokeStyle = 'rgba(150,150,150,0.4)'; c.lineWidth = gw; c.lineCap = 'round';
                c.beginPath(); c.moveTo(pumpX + pumpW, pumpY + 10); c.lineTo(pumpX + pumpW + 20, gy); c.lineTo(gr, gy); c.stroke();
                c.beginPath(); c.moveTo(gl, gy); c.lineTo(pumpX + pumpW + 20, gy); c.stroke();
            }
            
            feeds.forEach(fx => {
                if (flowing) {
                    this.animatedGallery(c, [{x: fx, y: gy}, {x: fx, y: feedTop}], gw - 1, alpha, true);
                    c.fillStyle = `rgba(0,0,0,${alpha * 0.6})`;
                    c.beginPath(); c.arc(fx, feedTop, 5, 0, Math.PI * 2); c.fill();
                } else {
                    c.strokeStyle = 'rgba(150,150,150,0.4)'; c.lineWidth = gw - 1;
                    c.beginPath(); c.moveTo(fx, gy); c.lineTo(fx, feedTop); c.stroke();
                }
            });
            
            if (flowing && state.isRunning && Math.random() < 0.1) {
                const fx = feeds[Math.floor(Math.random() * feeds.length)];
                state.particles.push(createParticle('drainback', fx, feedTop + 50));
            }
        },

        animatedGallery(c, pts, width, alpha, arrows) {
            c.lineCap = 'round'; c.lineJoin = 'round';
            c.strokeStyle = `rgba(60,60,60,${alpha})`; c.lineWidth = width;
            c.beginPath(); c.moveTo(pts[0].x, pts[0].y);
            for (let i = 1; i < pts.length; i++) c.lineTo(pts[i].x, pts[i].y);
            c.stroke();
            
            const off = state.galleryFlowOffset;
            for (let i = 1; i < pts.length; i++) {
                const p1 = pts[i-1], p2 = pts[i];
                const dx = p2.x - p1.x, dy = p2.y - p1.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const angle = Math.atan2(dy, dx);
                
                for (let d = off % 30; d < dist; d += 30) {
                    const t = d / dist;
                    c.fillStyle = `rgba(30,30,30,${alpha * 0.8})`;
                    c.beginPath(); c.arc(p1.x + dx * t, p1.y + dy * t, width * 0.4, 0, Math.PI * 2); c.fill();
                }
                
                if (arrows && dist > 40) {
                    c.save();
                    c.translate(p1.x + dx * 0.5, p1.y + dy * 0.5);
                    c.rotate(angle);
                    c.fillStyle = `rgba(255,255,255,${alpha * 0.9})`;
                    c.beginPath(); c.moveTo(6, 0); c.lineTo(-3, -4); c.lineTo(-3, 4); c.closePath(); c.fill();
                    c.restore();
                }
            }
        },

        particles(c) {
            state.particles = state.particles.filter(p => updateParticle(p));
            state.particles.forEach(p => drawParticle(c, p));
        }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // UI MODULE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const UI = {
        updateMeters() {
            const seized = state.damageStage >= 5;
            DOM.meters.forEach(el => {
                const cfg = METERS_CONFIG[el.dataset.meter];
                const val = seized ? 0 : cfg.getValue();
                const critical = !seized && (cfg.criticalBelow ? val < cfg.threshold : val > cfg.threshold);
                
                el.querySelector('.hud-meter-bar').style.width = val + '%';
                el.querySelector('.hud-meter-value').textContent = Math.round(val) + '%';
                
                [el, el.querySelector('.hud-meter-bar'), el.querySelector('.hud-meter-value')]
                    .forEach(e => e.classList.toggle('critical', critical));
            });
        },

        updateLights() {
            const now = Date.now();
            
            DOM.lights.forEach(el => {
                const lightKey = el.dataset.light;
                const shouldBeActive = LIGHTS_CONFIG[lightKey]();
                const lightState = lightDelays[lightKey];
                
                if (shouldBeActive) {
                    // Light condition is met
                    if (lightState.state === 'off') {
                        // Just triggered - start pending state
                        lightState.state = 'pending';
                        lightState.startTime = now;
                    } else if (lightState.state === 'pending') {
                        // Check if delay has elapsed
                        if (now - lightState.startTime >= lightState.delay) {
                            lightState.state = 'active';
                        }
                    }
                    // 'active' state stays active
                } else {
                    // Condition no longer met - turn off and roll new delay
                    if (lightState.state !== 'off') {
                        lightState.state = 'off';
                        rollLightDelay(lightKey); // New random delay for next time
                    }
                }
                
                // Apply CSS classes based on state
                el.classList.remove('active', 'pending');
                if (lightState.state === 'active') {
                    el.classList.add('active');
                } else if (lightState.state === 'pending') {
                    el.classList.add('pending');
                }
            });
        },

        updateOilSlider() {
            const { oilLevel: oil, countdownActive } = state;
            const critical = oil < TUNING.oil.critical;
            
            DOM.oilFill.style.width = oil + '%';
            DOM.oilBall.style.left = oil + '%';
            DOM.oilPercent.textContent = Math.round(oil);
            
            [DOM.oilFill, DOM.oilBall, DOM.oilPercentage].forEach(e => e.classList.toggle('low', critical));
            DOM.oilSection.classList.toggle('warning', critical);
            DOM.oilWarningIcon.style.display = critical ? 'inline' : 'none';
            DOM.refillOverlay.classList.toggle('active', countdownActive);
        },

        updateStatus() {
            const s = STAGE_DATA[state.damageStage];
            DOM.damageStage.textContent = s.name;
            DOM.damageStage.className = 'hud-status-stage ' + s.color;
            DOM.statusText.textContent = s.desc;
            DOM.damageStage.parentElement.classList.toggle('critical', state.damageStage > 0);
            
            // Update left panel damage stage styling
            for (let i = 0; i <= 5; i++) {
                DOM.hudLeftPanel.classList.toggle('damage-stage-' + i, state.damageStage === i && i > 0);
            }
            
            DOM.hudProblems.classList.toggle('visible', s.problems.length > 0);
            DOM.problemsList.innerHTML = s.problems.map(p => `<li><span class="problem-x">‚úï</span> ${p}</li>`).join('');
            
            DOM.conditionText.textContent = s.condition;
            DOM.conditionText.parentElement.classList.toggle('critical', state.damageStage >= 3);
            DOM.wrapper.classList.toggle('warning', state.countdownActive || state.damageStage >= 3);
        },

        updateRPM() {
            const reduction = state.damageStage >= 5 ? 100 : Math.round((state.damageStage * TUNING.damage.rpmLossPerStage) / TUNING.damage.baseRpm * 100);
            DOM.rpmValue.textContent = Math.round(state.rpm);
            DOM.rpmValue.classList.toggle('critical', state.rpm < 2000);
            DOM.rpmReduction.textContent = reduction > 0 ? `-${reduction}%` : '';
            DOM.rpmReduction.classList.toggle('visible', reduction > 0);
        },

        updateProgressBar() {
            DOM.stageItems.forEach((item, i) => {
                const isCurrent = i === state.damageStage;
                const isDamaged = i > 0 && i <= state.damageStage;
                const isNominalPast = i === 0 && state.damageStage >= 1;
                item.classList.toggle('current', isCurrent);
                item.classList.toggle('damaged', isDamaged);
                item.classList.toggle('nominal-past', isNominalPast);
            });
            
            const currentItem = DOM.stageItems[state.damageStage];
            if (currentItem) {
                const itemRect = currentItem.getBoundingClientRect();
                const barRect = DOM.stageProgressBar.getBoundingClientRect();
                DOM.stageArrow.style.left = (itemRect.left - barRect.left + itemRect.width / 2) + 'px';
            }
        },

        updateAll() {
            this.updateMeters();
            this.updateLights();
            this.updateOilSlider();
            this.updateStatus();
            this.updateRPM();
            this.updateProgressBar();
        }
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INFO POPUP
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function showInfoPopup(key) {
        if (state.countdownActive || state.popupVisible) return;
        const info = INFO_CONTENT[key];
        if (!info) return;
        
        state.infoVisible = true;
        state.statsFrozen = true;
        DOM.infoOverlay.classList.remove('damage-mode');
        DOM.infoTitle.textContent = info.title;
        DOM.infoStage.style.display = 'none';
        DOM.infoDescription.innerHTML = info.text;
        DOM.infoOverlay.classList.add('visible');
    }

    function showDamagePopup() {
        state.popupVisible = true;
        state.statsFrozen = true;
        DOM.infoOverlay.classList.add('damage-mode');
        DOM.infoTitle.textContent = '‚ö† Engine Damage';
        DOM.infoStage.style.display = 'block';
        DOM.infoStage.textContent = `Stage ${state.damageStage + 1}: ${STAGE_DATA[state.damageStage].name}`;
        DOM.infoDescription.innerHTML = DAMAGE_DESCRIPTIONS[state.damageStage];
        DOM.infoOverlay.classList.add('visible');
        DOM.refillOverlay.classList.remove('active');
        pulse(DOM.warningFlash);
    }

    function hideInfoOverlay() {
        DOM.infoOverlay.classList.remove('visible');
        if (state.popupVisible) {
            state.popupVisible = false;
            state.statsFrozen = false;
            state.graceActive = true;
            setTimeout(() => {
                state.graceActive = false;
                if (state.friction > TUNING.friction.countdownStart && state.damageStage < 5 && !state.countdownActive) startCountdown();
            }, 2000);
        } else if (state.infoVisible) {
            state.infoVisible = false;
            state.statsFrozen = false;
        }
    }

    DOM.infoOverlay.addEventListener('click', hideInfoOverlay);
    DOM.infoTriggers.forEach(el => el.addEventListener('click', e => { e.stopPropagation(); showInfoPopup(el.dataset.info); }));

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // COUNTDOWN
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function startCountdown() {
        state.countdownActive = true;
        state.countdownValue = 3;
        if (tutorial.idleActive) hideIdleHint();
        DOM.frictionHint.classList.add('active');  // Show swaying "Reduce Friction" text
        showCountdownNumber(3);
        state.countdownTimer = setInterval(() => {
            if (--state.countdownValue > 0) {
                showCountdownNumber(state.countdownValue);
            } else {
                clearInterval(state.countdownTimer);
                state.countdownActive = false;
                DOM.frictionHint.classList.remove('active');  // Hide hint when damage triggers
                DOM.refillOverlay.classList.remove('active');
                triggerDamage();
            }
        }, 1000);
    }

    function cancelCountdown(showSuccess = false) {
        if (state.countdownTimer) clearInterval(state.countdownTimer);
        state.countdownActive = false;
        DOM.countdownNumber.classList.remove('active');
        DOM.frictionHint.classList.remove('active');  // Hide hint
        DOM.refillOverlay.classList.remove('active');
        if (showSuccess) { 
            pulse(DOM.successCheckmark); 
            pulse(DOM.frictionSuccess);  // Show "Friction reduced!" text
            pulse(DOM.successFlash); 
        }
    }

    function showCountdownNumber(num) {
        DOM.countdownNumber.textContent = num;
        pulse(DOM.countdownNumber);
        pulse(DOM.warningFlash);
    }

    function triggerDamage() {
        if (state.damageStage >= 5) return;
        state.damageStage++;
        if (state.warpAppliedAtStage < state.damageStage) {
            state.warping = Math.min(100, state.warping + TUNING.damage.warpIncrements[state.damageStage]);
            state.warpAppliedAtStage = state.damageStage;
        }
        state.statsFrozen = true;
        if (tutorial.idleActive) hideIdleHint();
        showDamagePopup();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ZOOM (Pointer Events)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    DOM.canvas.addEventListener('pointerup', e => {
        if (state.popupVisible || state.infoVisible || tutorial.active || tutorial.idleActive) return;
        e.preventDefault();
        
        const rect = DOM.canvas.getBoundingClientRect();
        const relX = (e.clientX - rect.left) / rect.width;
        const relY = (e.clientY - rect.top) / rect.height;
        
        if (zoom.isZoomed) {
            zoom.isZoomed = false;
            zoom.targetLevel = TUNING.canvas.baseScale;
            zoom.targetOffsetX = zoom.targetOffsetY = 0;
            DOM.canvas.classList.remove('zoomed');
        } else {
            zoom.isZoomed = true;
            zoom.targetLevel = TUNING.canvas.zoomedScale;
            zoom.targetOffsetX = -(relX - 0.5) * 300;
            zoom.targetOffsetY = -(relY - 0.5) * 300;
            DOM.canvas.classList.add('zoomed');
        }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TUTORIAL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function startTutorial() {
        tutorial.active = true;
        tutorial.completed = false;
        tutorial.step = 0;
        DOM.tutorialOverlay.classList.add('active');
        DOM.tutorialOverlay.classList.remove('idle-hint');
        DOM.tutorialProgress.innerHTML = TUTORIAL_STEPS.map((_, i) => `<div class="tutorial-dot${i === 0 ? ' active' : ''}"></div>`).join('');
        showTutorialStep(0);
    }

    function showTutorialStep(i) {
        if (i >= TUTORIAL_STEPS.length) { endTutorial(); return; }
        const step = TUTORIAL_STEPS[i];
        const el = document.getElementById(step.target);
        const rect = el.getBoundingClientRect();
        
        DOM.tutorialSpotlight.style.cssText = `left:${rect.left - 8}px;top:${rect.top - 8}px;width:${rect.width + 16}px;height:${rect.height + 16}px`;
        
        const arrows = { below: '‚ñ≤', above: '‚ñº', left: '‚ñ∂', right: '‚óÄ' };
        DOM.tutorialArrow.textContent = arrows[step.position];
        DOM.tutorialArrowContainer.className = `tutorial-arrow-container position-${step.position}`;
        
        const x = step.position === 'left' ? rect.left - 8 : step.position === 'right' ? rect.right + 8 : rect.left + rect.width/2;
        const y = step.position === 'above' ? rect.top - 8 : step.position === 'below' ? rect.bottom + 8 : rect.top + rect.height/2;
        const transform = { below: 'translate(-50%,0)', above: 'translate(-50%,-100%)', left: 'translate(-100%,-50%)', right: 'translate(0,-50%)' }[step.position];
        DOM.tutorialArrowContainer.style.cssText = `left:${x}px;top:${y}px;transform:${transform}`;
        DOM.tutorialText.innerHTML = step.text + '<small>Tap to continue</small>';
        
        DOM.tutorialProgress.querySelectorAll('.tutorial-dot').forEach((dot, j) => {
            dot.classList.toggle('active', j === i);
            dot.classList.toggle('completed', j < i);
        });
        
        if (tutorial.autoTimer) clearTimeout(tutorial.autoTimer);
        tutorial.autoTimer = setTimeout(advanceTutorial, 5000);
    }

    function advanceTutorial() {
        if (!tutorial.active) return;
        if (++tutorial.step >= TUTORIAL_STEPS.length) endTutorial();
        else showTutorialStep(tutorial.step);
    }

    function endTutorial() {
        tutorial.active = false;
        tutorial.completed = true;
        DOM.tutorialOverlay.classList.remove('active');
        if (tutorial.autoTimer) clearTimeout(tutorial.autoTimer);
        resetIdleTimer();
    }

    function showIdleHint() {
        if (tutorial.active || state.countdownActive || state.popupVisible || state.infoVisible) return;
        tutorial.idleActive = true;
        DOM.tutorialOverlay.classList.add('active', 'idle-hint');
        const rect = DOM.oilSection.getBoundingClientRect();
        DOM.tutorialSpotlight.style.cssText = `left:${rect.left - 8}px;top:${rect.top - 8}px;width:${rect.width + 16}px;height:${rect.height + 16}px`;
        DOM.tutorialArrow.textContent = '‚ñº';
        DOM.tutorialArrowContainer.className = 'tutorial-arrow-container position-above';
        DOM.tutorialArrowContainer.style.cssText = `left:${rect.left + rect.width/2}px;top:${rect.top - 8}px;transform:translate(-50%,-100%)`;
        DOM.tutorialText.innerHTML = '<b>Move oil level slider</b> to affect the engine<small>Tap to dismiss</small>';
    }

    function hideIdleHint() { tutorial.idleActive = false; DOM.tutorialOverlay.classList.remove('active', 'idle-hint'); }

    function resetIdleTimer() {
        if (tutorial.idleTimer) clearTimeout(tutorial.idleTimer);
        if (tutorial.idleActive) hideIdleHint();
        if (tutorial.completed && !tutorial.active && !state.countdownActive && !state.popupVisible && !state.infoVisible)
            tutorial.idleTimer = setTimeout(showIdleHint, 15000);
    }

    DOM.tutorialOverlay.addEventListener('pointerup', () => tutorial.idleActive ? hideIdleHint() : advanceTutorial());
    DOM.tutorialArrowContainer.addEventListener('pointerup', e => { e.stopPropagation(); tutorial.idleActive ? hideIdleHint() : advanceTutorial(); });
    ['pointerdown', 'pointermove', 'scroll'].forEach(e => document.addEventListener(e, resetIdleTimer));

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // OIL SLIDER (Pointer Events)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let dragging = false;
    
    function updateOil(clientX) {
        const rect = DOM.oilTrack.getBoundingClientRect();
        state.oilLevel = clamp(((clientX - rect.left) / rect.width) * 100, 0, 100);
        resetIdleTimer();
    }

    DOM.oilTrack.addEventListener('pointerdown', e => { dragging = true; DOM.oilTrack.setPointerCapture(e.pointerId); updateOil(e.clientX); });
    DOM.oilBall.addEventListener('pointerdown', e => { dragging = true; DOM.oilTrack.setPointerCapture(e.pointerId); e.preventDefault(); });
    DOM.oilTrack.addEventListener('pointermove', e => { if (dragging) updateOil(e.clientX); });
    DOM.oilTrack.addEventListener('pointerup', e => { dragging = false; DOM.oilTrack.releasePointerCapture(e.pointerId); });
    DOM.oilTrack.addEventListener('pointercancel', e => { dragging = false; DOM.oilTrack.releasePointerCapture(e.pointerId); });

    DOM.refillBtn.addEventListener('click', () => { state.oilLevel = 100; resetIdleTimer(); });
    DOM.resetBtn.addEventListener('click', () => {
        Object.assign(state, {
            oilLevel: 100, lubrication: 100, friction: 0, warping: 0,
            damageStage: 0, warpAppliedAtStage: -1, rpm: TUNING.damage.baseRpm,
            isRunning: true, statsFrozen: false, popupVisible: false, infoVisible: false, graceActive: false,
            particles: []
        });
        cylinders.forEach(c => c.pistonWarp = 0);
        cancelCountdown(false);
        DOM.infoOverlay.classList.remove('visible');
        DOM.refillOverlay.classList.remove('active');
        DOM.frictionHint.classList.remove('active');
        DOM.frictionSuccess.classList.remove('active');
        // Reset left panel damage stage styling
        for (let i = 1; i <= 5; i++) DOM.hudLeftPanel.classList.remove('damage-stage-' + i);
        // Reset warning light delays
        Object.keys(lightDelays).forEach(key => {
            lightDelays[key].state = 'off';
            rollLightDelay(key);
        });
        DOM.lights.forEach(el => el.classList.remove('active', 'pending'));
        resetIdleTimer();
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ENGINE UPDATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function updateEngine() {
        if (state.damageStage >= 5) {
            state.isRunning = false;
            state.rpm = state.lubrication = state.friction = 0;
        }
        
        const rpmReduction = state.damageStage >= 5 ? 100 : Math.round((state.damageStage * TUNING.damage.rpmLossPerStage) / TUNING.damage.baseRpm * 100);
        
        if (state.isRunning) {
            state.crankAngle = (state.crankAngle + 12 * state.rpm / TUNING.damage.baseRpm) % 720;
            cylinders.forEach(c => c.update(state.crankAngle, rpmReduction));
        }
        
        if (state.statsFrozen || state.damageStage >= 5) { UI.updateAll(); return; }
        
        const dmgMult = 1 + state.damageStage * 0.3;
        const { oilLevel: oil, lubrication: lube } = state;
        
        state.lubrication = oil >= TUNING.oil.critical
            ? Math.min(100, lube + (100 - lube) * 0.03)
            : Math.max(0, lube - ((20 + (TUNING.oil.critical - oil) / TUNING.oil.critical * 13.3) / 60) * dmgMult);
        
        state.friction = state.lubrication < 50
            ? Math.min(100, state.friction + ((1 + (50 - state.lubrication) / 50 * 32) / 60) * dmgMult * (1 + state.rpm / TUNING.damage.baseRpm * state.damageStage * 0.1))
            : Math.max(0, state.friction - state.friction * (oil >= 50 ? 0.04 : oil >= TUNING.oil.critical ? 0.025 : 0.01));
        
        if (state.isRunning) {
            const targetRPM = TUNING.damage.baseRpm - state.damageStage * TUNING.damage.rpmLossPerStage - (state.friction > 80 ? 500 : 0);
            state.rpm = Math.max(0, state.rpm + (targetRPM - state.rpm) * 0.05);
        }
        
        const shouldCountdown = state.friction > TUNING.friction.countdownStart && state.damageStage < 5 && !state.countdownActive && !state.popupVisible && !state.infoVisible && !state.graceActive;
        if (shouldCountdown) { if (tutorial.idleActive) hideIdleHint(); startCountdown(); }
        if (state.countdownActive && state.friction < TUNING.friction.countdownCancel) cancelCountdown(true);
        
        UI.updateAll();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // RENDER
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function render() {
        const rect = DOM.wrapper.getBoundingClientRect();
        const { width: cw, height: ch, centerX: cx, centerY: cy, baseScale } = TUNING.canvas;
        
        ctx.clearRect(0, 0, rect.width, rect.height);
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, rect.width, rect.height);
        
        zoom.level = lerp(zoom.level, zoom.targetLevel, 0.12);
        zoom.offsetX = lerp(zoom.offsetX, zoom.targetOffsetX, 0.12);
        zoom.offsetY = lerp(zoom.offsetY, zoom.targetOffsetY, 0.12);
        
        ctx.save();
        const scale = Math.min(rect.width / cw, rect.height / ch) * baseScale * (zoom.level / baseScale);
        ctx.translate(rect.width / 2, rect.height / 2);
        ctx.scale(scale, scale);
        ctx.translate(-cx + zoom.offsetX, -cy + zoom.offsetY);
        
        Draw.engineBlock(ctx);
        Draw.galleries(ctx);
        Draw.oilPan(ctx);
        Draw.pumpAndPickup(ctx);
        Draw.crankshaft(ctx, state.crankAngle);
        cylinders.forEach(c => c.draw(ctx));
        Draw.particles(ctx);
        
        ctx.restore();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // GAME LOOP & INIT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function gameLoop() {
        updateEngine();
        render();
        requestAnimationFrame(gameLoop);
    }

    window.addEventListener('load', () => {
        setTimeout(startTutorial, 500);
        UI.updateProgressBar();
    });

    gameLoop();
    </script>
</body>
</html>
